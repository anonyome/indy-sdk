// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(libFFI)
    import libFFI
#endif

private extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_lib_2f6d_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_lib_2f6d_rustbuffer_free(self, $0) }
    }
}

private extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a libray of its own.

private extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// A helper class to read values out of a byte buffer.
private class Reader {
    let data: Data
    var offset: Data.Index

    init(data: Data) {
        self.data = data
        offset = 0
    }

    // Reads an integer at the current offset, in big-endian order, and advances
    // the offset on success. Throws if reading the integer would move the
    // offset past the end of the buffer.
    func readInt<T: FixedWidthInteger>() throws -> T {
        let range = offset ..< offset + MemoryLayout<T>.size
        guard data.count >= range.upperBound else {
            throw UniffiInternalError.bufferOverflow
        }
        if T.self == UInt8.self {
            let value = data[offset]
            offset += 1
            return value as! T
        }
        var value: T = 0
        _ = withUnsafeMutableBytes(of: &value) { data.copyBytes(to: $0, from: range) }
        offset = range.upperBound
        return value.bigEndian
    }

    // Reads an arbitrary number of bytes, to be used to read
    // raw bytes, this is useful when lifting strings
    func readBytes(count: Int) throws -> [UInt8] {
        let range = offset ..< (offset + count)
        guard data.count >= range.upperBound else {
            throw UniffiInternalError.bufferOverflow
        }
        var value = [UInt8](repeating: 0, count: count)
        value.withUnsafeMutableBufferPointer { buffer in
            data.copyBytes(to: buffer, from: range)
        }
        offset = range.upperBound
        return value
    }

    // Reads a float at the current offset.
    @inlinable
    func readFloat() throws -> Float {
        return Float(bitPattern: try readInt())
    }

    // Reads a float at the current offset.
    @inlinable
    func readDouble() throws -> Double {
        return Double(bitPattern: try readInt())
    }

    // Indicates if the offset has reached the end of the buffer.
    @inlinable
    func hasRemaining() -> Bool {
        return offset < data.count
    }
}

// A helper class to write values into a byte buffer.
private class Writer {
    var bytes: [UInt8]
    var offset: Array<UInt8>.Index

    init() {
        bytes = []
        offset = 0
    }

    func writeBytes<S>(_ byteArr: S) where S: Sequence, S.Element == UInt8 {
        bytes.append(contentsOf: byteArr)
    }

    // Writes an integer in big-endian order.
    //
    // Warning: make sure what you are trying to write
    // is in the correct type!
    func writeInt<T: FixedWidthInteger>(_ value: T) {
        var value = value.bigEndian
        withUnsafeBytes(of: &value) { bytes.append(contentsOf: $0) }
    }

    @inlinable
    func writeFloat(_ value: Float) {
        writeInt(value.bitPattern)
    }

    @inlinable
    func writeDouble(_ value: Double) {
        writeInt(value.bitPattern)
    }
}

// Types conforming to `Serializable` can be read and written in a bytebuffer.
private protocol Serializable {
    func write(into: Writer)
    static func read(from: Reader) throws -> Self
}

// Types confirming to `ViaFfi` can be transferred back-and-for over the FFI.
// This is analogous to the Rust trait of the same name.
private protocol ViaFfi: Serializable {
    associatedtype FfiType
    static func lift(_ v: FfiType) throws -> Self
    func lower() -> FfiType
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
private protocol Primitive {}

private extension Primitive {
    typealias FfiType = Self

    static func lift(_ v: Self) throws -> Self {
        return v
    }

    func lower() -> Self {
        return self
    }
}

// Types conforming to `ViaFfiUsingByteBuffer` lift and lower into a bytebuffer.
// Use this for complex types where it's hard to write a custom lift/lower.
private protocol ViaFfiUsingByteBuffer: Serializable {}

private extension ViaFfiUsingByteBuffer {
    typealias FfiType = RustBuffer

    static func lift(_ buf: FfiType) throws -> Self {
        let reader = Reader(data: Data(rustBuffer: buf))
        let value = try Self.read(from: reader)
        if reader.hasRemaining() {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    func lower() -> FfiType {
        let writer = Writer()
        write(into: writer)
        return RustBuffer(bytes: writer.bytes)
    }
}

// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
private enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

private let CALL_SUCCESS: Int8 = 0
private let CALL_ERROR: Int8 = 1
private let CALL_PANIC: Int8 = 2

private extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: {
        $0.deallocate()
        return UniffiInternalError.unexpectedRustCallError
    })
}

private func rustCallWithError<T, E: ViaFfiUsingByteBuffer & Error>(_: E.Type, _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: { try E.lift($0) })
}

private func makeRustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T, errorHandler: (RustBuffer) throws -> Error) throws -> T {
    var callStatus = RustCallStatus()
    let returnedVal = callback(&callStatus)
    switch callStatus.code {
    case CALL_SUCCESS:
        return returnedVal

    case CALL_ERROR:
        throw try errorHandler(callStatus.errorBuf)

    case CALL_PANIC:
        // When the rust code sees a panic, it tries to construct a RustBuffer
        // with the message.  But if that code panics, then it just sends back
        // an empty buffer.
        if callStatus.errorBuf.len > 0 {
            throw UniffiInternalError.rustPanic(try String.lift(callStatus.errorBuf))
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.rustPanic("Rust panic")
        }

    default:
        throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Protocols for converters we'll implement in templates

private protocol FfiConverter {
    associatedtype SwiftType
    associatedtype FfiType

    static func lift(_ ffiValue: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType

    static func read(from: Reader) throws -> SwiftType
    static func write(_ value: SwiftType, into: Writer)
}

private protocol FfiConverterUsingByteBuffer: FfiConverter where FfiType == RustBuffer {
    // Empty, because we want to declare some helper methods in the extension below.
}

extension FfiConverterUsingByteBuffer {
    static func lower(_ value: SwiftType) -> FfiType {
        let writer = Writer()
        Self.write(value, into: writer)
        return RustBuffer(bytes: writer.bytes)
    }

    static func lift(_ buf: FfiType) throws -> SwiftType {
        let reader = Reader(data: Data(rustBuffer: buf))
        let value = try Self.read(from: reader)
        if reader.hasRemaining() {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }
}

// Helpers for structural types. Note that because of canonical_names, it /should/ be impossible
// to make another `FfiConverterSequence` etc just using the UDL.
private enum FfiConverterSequence {
    static func write<T>(_ value: [T], into buf: Writer, writeItem: (T, Writer) -> Void) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            writeItem(item, buf)
        }
    }

    static func read<T>(from buf: Reader, readItem: (Reader) throws -> T) throws -> [T] {
        let len: Int32 = try buf.readInt()
        var seq = [T]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try readItem(buf))
        }
        return seq
    }
}

private enum FfiConverterOptional {
    static func write<T>(_ value: T?, into buf: Writer, writeItem: (T, Writer) -> Void) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        writeItem(value, buf)
    }

    static func read<T>(from buf: Reader, readItem: (Reader) throws -> T) throws -> T? {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try readItem(buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private enum FfiConverterDictionary {
    static func write<T>(_ value: [String: T], into buf: Writer, writeItem: (String, T, Writer) -> Void) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for (key, value) in value {
            writeItem(key, value, buf)
        }
    }

    static func read<T>(from buf: Reader, readItem: (Reader) throws -> (String, T)) throws -> [String: T] {
        let len: Int32 = try buf.readInt()
        var dict = [String: T]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let (key, value) = try readItem(buf)
            dict[key] = value
        }
        return dict
    }
}

// Public interface members begin here.

public func setRuntimeConfig(config: String) -> ErrorCode {
    let _retval = try!

        rustCall {
            lib_2f6d_set_runtime_config(config.lower(), $0)
        }
    return try! ErrorCode.lift(_retval)
}

public func openReader(xtype: String, configJson: String) throws -> Int32 {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_open_reader(xtype.lower(), configJson.lower(), $0)
        }
    return try Int32.lift(_retval)
}

public func openWriter(xtype: String, configJson: String) throws -> Int32 {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_open_writer(xtype.lower(), configJson.lower(), $0)
        }
    return try Int32.lift(_retval)
}

public func registerWalletStorage(xtype: String) throws {
    try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_register_wallet_storage(xtype.lower(), $0)
        }
}

public func createWallet(config: String, credentials: String) throws {
    try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_create_wallet(config.lower(), credentials.lower(), $0)
        }
}

public func openWallet(config: String, credentials: String) throws -> Int32 {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_open_wallet(config.lower(), credentials.lower(), $0)
        }
    return try Int32.lift(_retval)
}

public func exportWallet(walletHandle: Int32, exportConfig: String) throws {
    try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_export_wallet(walletHandle.lower(), exportConfig.lower(), $0)
        }
}

public func importWallet(config: String, credentials: String, importConfig: String) throws {
    try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_import_wallet(config.lower(), credentials.lower(), importConfig.lower(), $0)
        }
}

public func deleteWallet(config: String, credentials: String) throws {
    try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_delete_wallet(config.lower(), credentials.lower(), $0)
        }
}

public func closeWallet(walletHandle: Int32) throws {
    try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_close_wallet(walletHandle.lower(), $0)
        }
}

public func addWalletRecord(walletHandle: Int32, xtype: String, id: String, value: String, tagsJson: String) throws {
    try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_add_wallet_record(walletHandle.lower(), xtype.lower(), id.lower(), value.lower(), tagsJson.lower(), $0)
        }
}

public func updateWalletRecordValue(walletHandle: Int32, xtype: String, id: String, value: String) throws {
    try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_update_wallet_record_value(walletHandle.lower(), xtype.lower(), id.lower(), value.lower(), $0)
        }
}

public func updateWalletRecordTags(walletHandle: Int32, xtype: String, id: String, tagsJson: String) throws {
    try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_update_wallet_record_tags(walletHandle.lower(), xtype.lower(), id.lower(), tagsJson.lower(), $0)
        }
}

public func addWalletRecordTags(walletHandle: Int32, xtype: String, id: String, tagsJson: String) throws {
    try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_add_wallet_record_tags(walletHandle.lower(), xtype.lower(), id.lower(), tagsJson.lower(), $0)
        }
}

public func deleteWalletRecordTags(walletHandle: Int32, xtype: String, id: String, tagNamesJson: String) throws {
    try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_delete_wallet_record_tags(walletHandle.lower(), xtype.lower(), id.lower(), tagNamesJson.lower(), $0)
        }
}

public func deleteWalletRecord(walletHandle: Int32, xtype: String, id: String) throws {
    try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_delete_wallet_record(walletHandle.lower(), xtype.lower(), id.lower(), $0)
        }
}

public func getWalletRecord(walletHandle: Int32, xtype: String, id: String, optionsJson: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_get_wallet_record(walletHandle.lower(), xtype.lower(), id.lower(), optionsJson.lower(), $0)
        }
    return try String.lift(_retval)
}

public func openWalletSearch(walletHandle: Int32, xtype: String, queryJson: String, optionsJson: String) throws -> Int32 {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_open_wallet_search(walletHandle.lower(), xtype.lower(), queryJson.lower(), optionsJson.lower(), $0)
        }
    return try Int32.lift(_retval)
}

public func fetchWalletSearchNextRecords(walletHandle: Int32, walletSearchHandle: Int32, count: UInt64) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_fetch_wallet_search_next_records(walletHandle.lower(), walletSearchHandle.lower(), count.lower(), $0)
        }
    return try String.lift(_retval)
}

public func closeWalletSearch(walletSearchHandle: Int32) throws {
    try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_close_wallet_search(walletSearchHandle.lower(), $0)
        }
}

public func generateWalletKey(config: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_generate_wallet_key(config.lower(), $0)
        }
    return try String.lift(_retval)
}

public func createPoolLedgerConfig(poolName: String, poolConfig: String) throws {
    try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_create_pool_ledger_config(poolName.lower(), poolConfig.lower(), $0)
        }
}

public func openPoolLedger(poolName: String, config: String) throws -> Int32 {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_open_pool_ledger(poolName.lower(), config.lower(), $0)
        }
    return try Int32.lift(_retval)
}

public func refreshPoolLedger(poolHandle: Int32) throws {
    try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_refresh_pool_ledger(poolHandle.lower(), $0)
        }
}

public func listPools() throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_list_pools($0)
        }
    return try String.lift(_retval)
}

public func closePoolLedger(poolHandle: Int32) throws {
    try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_close_pool_ledger(poolHandle.lower(), $0)
        }
}

public func deletePoolLedger(poolName: String) throws {
    try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_delete_pool_ledger(poolName.lower(), $0)
        }
}

public func setProtocolVersion(protocolVersion: UInt64) throws {
    try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_set_protocol_version(protocolVersion.lower(), $0)
        }
}

public func createAndStoreMyDid(walletHandle: Int32, didJson: String) throws -> StringString {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_create_and_store_my_did(walletHandle.lower(), didJson.lower(), $0)
        }
    return try StringString.lift(_retval)
}

public func replaceKeysStart(walletHandle: Int32, tgtDid: String, identityJson: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_replace_keys_start(walletHandle.lower(), tgtDid.lower(), identityJson.lower(), $0)
        }
    return try String.lift(_retval)
}

public func replaceKeysApply(walletHandle: Int32, tgtDid: String) throws {
    try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_replace_keys_apply(walletHandle.lower(), tgtDid.lower(), $0)
        }
}

public func storeTheirDid(walletHandle: Int32, identityJson: String) throws {
    try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_store_their_did(walletHandle.lower(), identityJson.lower(), $0)
        }
}

public func keyForDid(poolHandle: Int32, walletHandle: Int32, did: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_key_for_did(poolHandle.lower(), walletHandle.lower(), did.lower(), $0)
        }
    return try String.lift(_retval)
}

public func keyForLocalDid(walletHandle: Int32, did: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_key_for_local_did(walletHandle.lower(), did.lower(), $0)
        }
    return try String.lift(_retval)
}

public func setEndpointForDid(walletHandle: Int32, did: String, address: String, transportKey: String) throws {
    try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_set_endpoint_for_did(walletHandle.lower(), did.lower(), address.lower(), transportKey.lower(), $0)
        }
}

public func getEndpointForDid(walletHandle: Int32, poolHandle: Int32, did: String) throws -> StringOptString {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_get_endpoint_for_did(walletHandle.lower(), poolHandle.lower(), did.lower(), $0)
        }
    return try StringOptString.lift(_retval)
}

public func setDidMetadata(walletHandle: Int32, tgtDid: String, metadata: String) throws {
    try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_set_did_metadata(walletHandle.lower(), tgtDid.lower(), metadata.lower(), $0)
        }
}

public func getDidMetadata(walletHandle: Int32, tgtDid: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_get_did_metadata(walletHandle.lower(), tgtDid.lower(), $0)
        }
    return try String.lift(_retval)
}

public func getMyDidWithMetadata(walletHandle: Int32, myDid: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_get_my_did_with_metadata(walletHandle.lower(), myDid.lower(), $0)
        }
    return try String.lift(_retval)
}

public func listMyDidsWithMetadata(walletHandle: Int32) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_list_my_dids_with_metadata(walletHandle.lower(), $0)
        }
    return try String.lift(_retval)
}

public func abbreviateVerkey(tgtDid: String, verkey: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_abbreviate_verkey(tgtDid.lower(), verkey.lower(), $0)
        }
    return try String.lift(_retval)
}

public func qualifyDid(walletHandle: Int32, did: String, method: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_qualify_did(walletHandle.lower(), did.lower(), method.lower(), $0)
        }
    return try String.lift(_retval)
}

public func getSchema(poolHandle: Int32, walletHandle: Int32, submitterDid: String, id: String, optionsJson: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_get_schema(poolHandle.lower(), walletHandle.lower(), submitterDid.lower(), id.lower(), optionsJson.lower(), $0)
        }
    return try String.lift(_retval)
}

public func getCredDef(poolHandle: Int32, walletHandle: Int32, submitterDid: String, id: String, optionsJson: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_get_cred_def(poolHandle.lower(), walletHandle.lower(), submitterDid.lower(), id.lower(), optionsJson.lower(), $0)
        }
    return try String.lift(_retval)
}

public func purgeSchemaCache(walletHandle: Int32, optionsJson: String) throws {
    try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_purge_schema_cache(walletHandle.lower(), optionsJson.lower(), $0)
        }
}

public func purgeCredDefCache(walletHandle: Int32, optionsJson: String) throws {
    try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_purge_cred_def_cache(walletHandle.lower(), optionsJson.lower(), $0)
        }
}

public func createKey(walletHandle: Int32, myKeyJson: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_create_key(walletHandle.lower(), myKeyJson.lower(), $0)
        }
    return try String.lift(_retval)
}

public func setKeyMetadata(walletHandle: Int32, verkey: String, metadata: String) throws {
    try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_set_key_metadata(walletHandle.lower(), verkey.lower(), metadata.lower(), $0)
        }
}

public func getKeyMetadata(walletHandle: Int32, verkey: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_get_key_metadata(walletHandle.lower(), verkey.lower(), $0)
        }
    return try String.lift(_retval)
}

public func sign(walletHandle: Int32, signerVk: String, message: [UInt8]) throws -> [UInt8] {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_sign(walletHandle.lower(), signerVk.lower(), FfiConverterSequenceUInt8.lower(message), $0)
        }
    return try FfiConverterSequenceUInt8.lift(_retval)
}

public func verify(signerVk: String, message: [UInt8], signature: [UInt8]) throws -> Bool {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_verify(signerVk.lower(), FfiConverterSequenceUInt8.lower(message), FfiConverterSequenceUInt8.lower(signature), $0)
        }
    return try Bool.lift(_retval)
}

public func authCrypt(walletHandle: Int32, senderVk: String, recipientVk: String, message: [UInt8]) throws -> [UInt8] {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_auth_crypt(walletHandle.lower(), senderVk.lower(), recipientVk.lower(), FfiConverterSequenceUInt8.lower(message), $0)
        }
    return try FfiConverterSequenceUInt8.lift(_retval)
}

public func authDecrypt(walletHandle: Int32, recipientVk: String, encryptedMessage: [UInt8]) throws -> StringVecU8 {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_auth_decrypt(walletHandle.lower(), recipientVk.lower(), FfiConverterSequenceUInt8.lower(encryptedMessage), $0)
        }
    return try StringVecU8.lift(_retval)
}

public func anonCrypt(recipientVk: String, message: [UInt8]) throws -> [UInt8] {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_anon_crypt(recipientVk.lower(), FfiConverterSequenceUInt8.lower(message), $0)
        }
    return try FfiConverterSequenceUInt8.lift(_retval)
}

public func anonDecrypt(walletHandle: Int32, recipientVk: String, encryptedMessage: [UInt8]) throws -> [UInt8] {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_anon_decrypt(walletHandle.lower(), recipientVk.lower(), FfiConverterSequenceUInt8.lower(encryptedMessage), $0)
        }
    return try FfiConverterSequenceUInt8.lift(_retval)
}

public func packMessage(walletHandle: Int32, message: [UInt8], receiverKeys: String, sender: String) throws -> [UInt8] {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_pack_message(walletHandle.lower(), FfiConverterSequenceUInt8.lower(message), receiverKeys.lower(), sender.lower(), $0)
        }
    return try FfiConverterSequenceUInt8.lift(_retval)
}

public func unpackMessage(walletHandle: Int32, jwe: [UInt8]) throws -> [UInt8] {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_unpack_message(walletHandle.lower(), FfiConverterSequenceUInt8.lower(jwe), $0)
        }
    return try FfiConverterSequenceUInt8.lift(_retval)
}

public func collectMetrics() throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_collect_metrics($0)
        }
    return try String.lift(_retval)
}

public func isPairwiseExists(walletHandle: Int32, theirDid: String) throws -> Bool {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_is_pairwise_exists(walletHandle.lower(), theirDid.lower(), $0)
        }
    return try Bool.lift(_retval)
}

public func createPairwise(walletHandle: Int32, theirDid: String, myDid: String, metadata: String) throws {
    try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_create_pairwise(walletHandle.lower(), theirDid.lower(), myDid.lower(), metadata.lower(), $0)
        }
}

public func listPairwise(walletHandle: Int32) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_list_pairwise(walletHandle.lower(), $0)
        }
    return try String.lift(_retval)
}

public func getPairwise(walletHandle: Int32, theirDid: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_get_pairwise(walletHandle.lower(), theirDid.lower(), $0)
        }
    return try String.lift(_retval)
}

public func setPairwiseMetadata(walletHandle: Int32, theirDid: String, metadata: String) throws {
    try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_set_pairwise_metadata(walletHandle.lower(), theirDid.lower(), metadata.lower(), $0)
        }
}

public func signAndSubmitRequest(poolHandle: Int32, walletHandle: Int32, submitterDid: String, requestJson: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_sign_and_submit_request(poolHandle.lower(), walletHandle.lower(), submitterDid.lower(), requestJson.lower(), $0)
        }
    return try String.lift(_retval)
}

public func submitRequest(poolHandle: Int32, requestJson: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_submit_request(poolHandle.lower(), requestJson.lower(), $0)
        }
    return try String.lift(_retval)
}

public func submitAction(poolHandle: Int32, requestJson: String, nodes: String, waitTimeout: Int32) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_submit_action(poolHandle.lower(), requestJson.lower(), nodes.lower(), waitTimeout.lower(), $0)
        }
    return try String.lift(_retval)
}

public func signRequest(walletHandle: Int32, submitterDid: String, requestJson: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_sign_request(walletHandle.lower(), submitterDid.lower(), requestJson.lower(), $0)
        }
    return try String.lift(_retval)
}

public func multiSignRequest(walletHandle: Int32, submitterDid: String, requestJson: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_multi_sign_request(walletHandle.lower(), submitterDid.lower(), requestJson.lower(), $0)
        }
    return try String.lift(_retval)
}

public func buildGetDdoRequest(submitterDid: String, targetDid: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_build_get_ddo_request(submitterDid.lower(), targetDid.lower(), $0)
        }
    return try String.lift(_retval)
}

public func buildNymRequest(submitterDid: String, targetDid: String, verkey: String, data: String, role: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_build_nym_request(submitterDid.lower(), targetDid.lower(), verkey.lower(), data.lower(), role.lower(), $0)
        }
    return try String.lift(_retval)
}

public func buildGetNymRequest(submitterDid: String, targetDid: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_build_get_nym_request(submitterDid.lower(), targetDid.lower(), $0)
        }
    return try String.lift(_retval)
}

public func parseGetNymResponse(getNymResponse: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_parse_get_nym_response(getNymResponse.lower(), $0)
        }
    return try String.lift(_retval)
}

public func buildGetTxnRequest(submitterDid: String, ledgerType: String, seqNo: Int32) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_build_get_txn_request(submitterDid.lower(), ledgerType.lower(), seqNo.lower(), $0)
        }
    return try String.lift(_retval)
}

public func buildAttribRequest(submitterDid: String, targetDid: String, hash: String, raw: String, enc: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_build_attrib_request(submitterDid.lower(), targetDid.lower(), hash.lower(), raw.lower(), enc.lower(), $0)
        }
    return try String.lift(_retval)
}

public func buildGetAttribRequest(submitterDid: String, targetDid: String, raw: String, hash: String, enc: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_build_get_attrib_request(submitterDid.lower(), targetDid.lower(), raw.lower(), hash.lower(), enc.lower(), $0)
        }
    return try String.lift(_retval)
}

public func buildSchemaRequest(ubmitterDid: String, data: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_build_schema_request(ubmitterDid.lower(), data.lower(), $0)
        }
    return try String.lift(_retval)
}

public func buildGetSchemaRequest(submitterDid: String, id: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_build_get_schema_request(submitterDid.lower(), id.lower(), $0)
        }
    return try String.lift(_retval)
}

public func parseGetSchemaResponse(getSchemaResponse: String) throws -> StringString {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_parse_get_schema_response(getSchemaResponse.lower(), $0)
        }
    return try StringString.lift(_retval)
}

public func buildCredDefRequest(submitterDid: String, data: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_build_cred_def_request(submitterDid.lower(), data.lower(), $0)
        }
    return try String.lift(_retval)
}

public func buildGetCredDefRequest(submitterDid: String, id: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_build_get_cred_def_request(submitterDid.lower(), id.lower(), $0)
        }
    return try String.lift(_retval)
}

public func parseGetCredDefResponse(getCredDefResponse: String) throws -> StringString {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_parse_get_cred_def_response(getCredDefResponse.lower(), $0)
        }
    return try StringString.lift(_retval)
}

public func buildNodeRequest(submitterDid: String, targetDid: String, data: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_build_node_request(submitterDid.lower(), targetDid.lower(), data.lower(), $0)
        }
    return try String.lift(_retval)
}

public func buildGetValidatorInfoRequest(submitterDid: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_build_get_validator_info_request(submitterDid.lower(), $0)
        }
    return try String.lift(_retval)
}

public func buildPoolConfigRequest(submitterDid: String, writes: Bool, force: Bool) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_build_pool_config_request(submitterDid.lower(), writes.lower(), force.lower(), $0)
        }
    return try String.lift(_retval)
}

public func buildPoolRestartRequest(submitterDid: String, action: String, datetime: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_build_pool_restart_request(submitterDid.lower(), action.lower(), datetime.lower(), $0)
        }
    return try String.lift(_retval)
}

public func buildPoolUpgradeRequest(submitterDid: String, name: String, version: String, action: String, sha256: String, upgradeTimeout: UInt32, schedule: String, justification: String, reinstall: Bool, force: Bool, package: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_build_pool_upgrade_request(submitterDid.lower(), name.lower(), version.lower(), action.lower(), sha256.lower(), upgradeTimeout.lower(), schedule.lower(), justification.lower(), reinstall.lower(), force.lower(), package.lower(), $0)
        }
    return try String.lift(_retval)
}

public func buildRevocRegDefRequest(submitterDid: String, data: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_build_revoc_reg_def_request(submitterDid.lower(), data.lower(), $0)
        }
    return try String.lift(_retval)
}

public func buildGetRevocRegDefRequest(submitterDid: String, id: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_build_get_revoc_reg_def_request(submitterDid.lower(), id.lower(), $0)
        }
    return try String.lift(_retval)
}

public func parseGetRevocRegDefResponse(getRevocRegDefResponse: String) throws -> StringString {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_parse_get_revoc_reg_def_response(getRevocRegDefResponse.lower(), $0)
        }
    return try StringString.lift(_retval)
}

public func buildRevocRegEntryRequest(submitterDid: String, revocRegDefId: String, revDefType: String, value: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_build_revoc_reg_entry_request(submitterDid.lower(), revocRegDefId.lower(), revDefType.lower(), value.lower(), $0)
        }
    return try String.lift(_retval)
}

public func buildGetRevocRegRequest(submitterDid: String, revocRegDefId: String, timestamp: Int64) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_build_get_revoc_reg_request(submitterDid.lower(), revocRegDefId.lower(), timestamp.lower(), $0)
        }
    return try String.lift(_retval)
}

public func parseGetRevocRegResponse(getRevocRegResponse: String) throws -> StringStringU64 {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_parse_get_revoc_reg_response(getRevocRegResponse.lower(), $0)
        }
    return try StringStringU64.lift(_retval)
}

public func buildGetRevocRegDeltaRequest(submitterDid: String, revocRegDefId: String, from: Int64, to: Int64) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_build_get_revoc_reg_delta_request(submitterDid.lower(), revocRegDefId.lower(), from.lower(), to.lower(), $0)
        }
    return try String.lift(_retval)
}

public func parseGetRevocRegDeltaResponse(getRevocRegDeltaResponse: String) throws -> StringStringU64 {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_parse_get_revoc_reg_delta_response(getRevocRegDeltaResponse.lower(), $0)
        }
    return try StringStringU64.lift(_retval)
}

public func getResponseMetadata(response: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_get_response_metadata(response.lower(), $0)
        }
    return try String.lift(_retval)
}

public func buildAuthRuleRequest(submitterDid: String, txnType: String, action: String, field: String, oldValue: String, newValue: String, constraint: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_build_auth_rule_request(submitterDid.lower(), txnType.lower(), action.lower(), field.lower(), oldValue.lower(), newValue.lower(), constraint.lower(), $0)
        }
    return try String.lift(_retval)
}

public func buildAuthRulesRequest(submitterDid: String, data: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_build_auth_rules_request(submitterDid.lower(), data.lower(), $0)
        }
    return try String.lift(_retval)
}

public func buildGetAuthRuleRequest(submitterDid: String, txnType: String, action: String, field: String, oldValue: String, newValue: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_build_get_auth_rule_request(submitterDid.lower(), txnType.lower(), action.lower(), field.lower(), oldValue.lower(), newValue.lower(), $0)
        }
    return try String.lift(_retval)
}

public func buildTxnAuthorAgreementRequest(submitterDid: String, text: String, version: String, ratificationTs: UInt64?, retirementTs: UInt64?) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_build_txn_author_agreement_request(submitterDid.lower(), text.lower(), version.lower(), FfiConverterOptionUInt64.lower(ratificationTs), FfiConverterOptionUInt64.lower(retirementTs), $0)
        }
    return try String.lift(_retval)
}

public func buildDisableAllTxnAuthorAgreementsRequest(submitterDid: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_build_disable_all_txn_author_agreements_request(submitterDid.lower(), $0)
        }
    return try String.lift(_retval)
}

public func buildGetTxnAuthorAgreementRequest(submitterDid: String, data: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_build_get_txn_author_agreement_request(submitterDid.lower(), data.lower(), $0)
        }
    return try String.lift(_retval)
}

public func buildAcceptanceMechanismsRequest(submitterDid: String, aml: String, version: String, amlContext: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_build_acceptance_mechanisms_request(submitterDid.lower(), aml.lower(), version.lower(), amlContext.lower(), $0)
        }
    return try String.lift(_retval)
}

public func buildGetAcceptanceMechanismsRequest(submitterDid: String, timestamp: Int64, version: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_build_get_acceptance_mechanisms_request(submitterDid.lower(), timestamp.lower(), version.lower(), $0)
        }
    return try String.lift(_retval)
}

public func appendTxnAuthorAgreementAcceptanceToRequest(requestJson: String, text: String, version: String, taaDigest: String, mechanism: String, time: UInt64) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_append_txn_author_agreement_acceptance_to_request(requestJson.lower(), text.lower(), version.lower(), taaDigest.lower(), mechanism.lower(), time.lower(), $0)
        }
    return try String.lift(_retval)
}

public func appendRequestEndorser(requestJson: String, endorserDid: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_append_request_endorser(requestJson.lower(), endorserDid.lower(), $0)
        }
    return try String.lift(_retval)
}

public func buildLedgersFreezeRequest(submitterDid: String, ledgersIds: [UInt64]) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_build_ledgers_freeze_request(submitterDid.lower(), FfiConverterSequenceUInt64.lower(ledgersIds), $0)
        }
    return try String.lift(_retval)
}

public func buildGetFrozenLedgersRequest(submitterDid: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_build_get_frozen_ledgers_request(submitterDid.lower(), $0)
        }
    return try String.lift(_retval)
}

public func issuerCreateSchema(issuerDid: String, name: String, version: String, attrs: String) throws -> StringString {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_issuer_create_schema(issuerDid.lower(), name.lower(), version.lower(), attrs.lower(), $0)
        }
    return try StringString.lift(_retval)
}

public func issuerCreateAndStoreCredentialDef(walletHandle: Int32, issuerDid: String, schemaJson: String, tag: String, signatureType: String, configJson: String) throws -> StringString {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_issuer_create_and_store_credential_def(walletHandle.lower(), issuerDid.lower(), schemaJson.lower(), tag.lower(), signatureType.lower(), configJson.lower(), $0)
        }
    return try StringString.lift(_retval)
}

public func issuerRotateCredentialDefStart(walletHandle: Int32, credDefId: String, configJson: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_issuer_rotate_credential_def_start(walletHandle.lower(), credDefId.lower(), configJson.lower(), $0)
        }
    return try String.lift(_retval)
}

public func issuerRotateCredentialDefApply(walletHandle: Int32, credDefId: String) throws {
    try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_issuer_rotate_credential_def_apply(walletHandle.lower(), credDefId.lower(), $0)
        }
}

public func issuerCreateAndStoreRevocReg(walletHandle: Int32, issuerDid: String, revocDefType: String, tag: String, credDefId: String, configJson: String, tailsWriterHandle: Int32) throws -> StringStringString {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_issuer_create_and_store_revoc_reg(walletHandle.lower(), issuerDid.lower(), revocDefType.lower(), tag.lower(), credDefId.lower(), configJson.lower(), tailsWriterHandle.lower(), $0)
        }
    return try StringStringString.lift(_retval)
}

public func issuerCreateCredentialOffer(walletHandle: Int32, credDefId: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_issuer_create_credential_offer(walletHandle.lower(), credDefId.lower(), $0)
        }
    return try String.lift(_retval)
}

public func issuerCreateCredential(walletHandle: Int32, credOfferJson: String, credReqJson: String, credValuesJson: String, revRegId: String, blobStorageReaderHandle: Int32) throws -> StringStringString122 {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_issuer_create_credential(walletHandle.lower(), credOfferJson.lower(), credReqJson.lower(), credValuesJson.lower(), revRegId.lower(), blobStorageReaderHandle.lower(), $0)
        }
    return try StringStringString122.lift(_retval)
}

public func issuerRevokeCredential(walletHandle: Int32, blobStorageReaderCfgHandle: Int32, revRegId: String, credRevocId: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_issuer_revoke_credential(walletHandle.lower(), blobStorageReaderCfgHandle.lower(), revRegId.lower(), credRevocId.lower(), $0)
        }
    return try String.lift(_retval)
}

public func issuerMergeRevocationRegistryDeltas(revRegDeltaJson: String, otherRevRegDeltaJson: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_issuer_merge_revocation_registry_deltas(revRegDeltaJson.lower(), otherRevRegDeltaJson.lower(), $0)
        }
    return try String.lift(_retval)
}

public func proverCreateMasterSecret(walletHandle: Int32, masterSecretId: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_prover_create_master_secret(walletHandle.lower(), masterSecretId.lower(), $0)
        }
    return try String.lift(_retval)
}

public func proverGetCredential(walletHandle: Int32, credId: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_prover_get_credential(walletHandle.lower(), credId.lower(), $0)
        }
    return try String.lift(_retval)
}

public func proverDeleteCredential(walletHandle: Int32, credId: String) throws {
    try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_prover_delete_credential(walletHandle.lower(), credId.lower(), $0)
        }
}

public func proverCreateCredentialReq(walletHandle: Int32, proverDid: String, credOfferJson: String, credDefJson: String, masterSecretId: String) throws -> StringString {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_prover_create_credential_req(walletHandle.lower(), proverDid.lower(), credOfferJson.lower(), credDefJson.lower(), masterSecretId.lower(), $0)
        }
    return try StringString.lift(_retval)
}

public func proverSetCredentialAttrTagPolicy(walletHandle: Int32, credDefId: String, tagAttrsJson: String, retroactive: Bool) throws {
    try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_prover_set_credential_attr_tag_policy(walletHandle.lower(), credDefId.lower(), tagAttrsJson.lower(), retroactive.lower(), $0)
        }
}

public func proverGetCredentialAttrTagPolicy(walletHandle: Int32, credId: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_prover_get_credential_attr_tag_policy(walletHandle.lower(), credId.lower(), $0)
        }
    return try String.lift(_retval)
}

public func proverStoreCredential(walletHandle: Int32, credId: String, credReqMetadataJson: String, credJson: String, credDefJson: String, revRegDefJson: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_prover_store_credential(walletHandle.lower(), credId.lower(), credReqMetadataJson.lower(), credJson.lower(), credDefJson.lower(), revRegDefJson.lower(), $0)
        }
    return try String.lift(_retval)
}

public func proverGetCredentials(walletHandle: Int32, filterJson: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_prover_get_credentials(walletHandle.lower(), filterJson.lower(), $0)
        }
    return try String.lift(_retval)
}

public func proverSearchCredentials(walletHandle: Int32, queryJson: String) throws -> SearchHandleAndLength {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_prover_search_credentials(walletHandle.lower(), queryJson.lower(), $0)
        }
    return try SearchHandleAndLength.lift(_retval)
}

public func proverFetchCredentials(searchHandle: Int32, count: UInt64) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_prover_fetch_credentials(searchHandle.lower(), count.lower(), $0)
        }
    return try String.lift(_retval)
}

public func proverCloseCredentialsSearch(searchHandle: Int32) throws {
    try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_prover_close_credentials_search(searchHandle.lower(), $0)
        }
}

public func proverGetCredentialsForProofReq(walletHandle: Int32, proofRequestJson: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_prover_get_credentials_for_proof_req(walletHandle.lower(), proofRequestJson.lower(), $0)
        }
    return try String.lift(_retval)
}

public func proverSearchCredentialsForProofReq(walletHandle: Int32, proofRequestJson: String, extraQueryJson: String) throws -> Int32 {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_prover_search_credentials_for_proof_req(walletHandle.lower(), proofRequestJson.lower(), extraQueryJson.lower(), $0)
        }
    return try Int32.lift(_retval)
}

public func proverFetchCredentialsForProofReq(searchHandle: Int32, itemReferent: String, count: UInt64) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_prover_fetch_credentials_for_proof_req(searchHandle.lower(), itemReferent.lower(), count.lower(), $0)
        }
    return try String.lift(_retval)
}

public func proverCloseCredentialsSearchForProofReq(searchHandle: Int32) throws {
    try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_prover_close_credentials_search_for_proof_req(searchHandle.lower(), $0)
        }
}

public func proverCreateProof(walletHandle: Int32, proofReqJson: String, requestedCredentialsJson: String, masterSecretId: String, schemasJson: String, credentialDefsJson: String, revStatesJson: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_prover_create_proof(walletHandle.lower(), proofReqJson.lower(), requestedCredentialsJson.lower(), masterSecretId.lower(), schemasJson.lower(), credentialDefsJson.lower(), revStatesJson.lower(), $0)
        }
    return try String.lift(_retval)
}

public func verifierVerifyProof(proofRequestJson: String, proofJson: String, schemasJson: String, credentialDefsJson: String, revRegDefsJson: String, revRegsJson: String) throws -> Bool {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_verifier_verify_proof(proofRequestJson.lower(), proofJson.lower(), schemasJson.lower(), credentialDefsJson.lower(), revRegDefsJson.lower(), revRegsJson.lower(), $0)
        }
    return try Bool.lift(_retval)
}

public func createRevocationState(blobStorageReaderHandle: Int32, revRegDefJson: String, revRegDeltaJson: String, timestamp: UInt64, credRevId: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_create_revocation_state(blobStorageReaderHandle.lower(), revRegDefJson.lower(), revRegDeltaJson.lower(), timestamp.lower(), credRevId.lower(), $0)
        }
    return try String.lift(_retval)
}

public func updateRevocationState(blobStorageReaderHandle: Int32, revStateJson: String, revRegDefJson: String, revRegDeltaJson: String, timestamp: UInt64, credRevId: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_update_revocation_state(blobStorageReaderHandle.lower(), revStateJson.lower(), revRegDefJson.lower(), revRegDeltaJson.lower(), timestamp.lower(), credRevId.lower(), $0)
        }
    return try String.lift(_retval)
}

public func generateNonce() throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_generate_nonce($0)
        }
    return try String.lift(_retval)
}

public func toUnqualified(entity: String) throws -> String {
    let _retval = try

        rustCallWithError(IndyError2.self) {
            lib_2f6d_to_unqualified(entity.lower(), $0)
        }
    return try String.lift(_retval)
}

public struct IndyError {
    public var errorCode: ErrorCode
    public var message: String
    public var indyBacktrace: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(errorCode: ErrorCode, message: String, indyBacktrace: String?) {
        self.errorCode = errorCode
        self.message = message
        self.indyBacktrace = indyBacktrace
    }
}

extension IndyError: Equatable, Hashable {
    public static func == (lhs: IndyError, rhs: IndyError) -> Bool {
        if lhs.errorCode != rhs.errorCode {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        if lhs.indyBacktrace != rhs.indyBacktrace {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(errorCode)
        hasher.combine(message)
        hasher.combine(indyBacktrace)
    }
}

private extension IndyError {
    static func read(from buf: Reader) throws -> IndyError {
        return try IndyError(
            errorCode: ErrorCode.read(from: buf),
            message: String.read(from: buf),
            indyBacktrace: FfiConverterOptionString.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        errorCode.write(into: buf)
        message.write(into: buf)
        FfiConverterOptionString.write(indyBacktrace, into: buf)
    }
}

extension IndyError: ViaFfiUsingByteBuffer, ViaFfi {}

public struct ErrorDetails {
    public var message: String
    public var backtrace: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(message: String, backtrace: String?) {
        self.message = message
        self.backtrace = backtrace
    }
}

extension ErrorDetails: Equatable, Hashable {
    public static func == (lhs: ErrorDetails, rhs: ErrorDetails) -> Bool {
        if lhs.message != rhs.message {
            return false
        }
        if lhs.backtrace != rhs.backtrace {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(message)
        hasher.combine(backtrace)
    }
}

private extension ErrorDetails {
    static func read(from buf: Reader) throws -> ErrorDetails {
        return try ErrorDetails(
            message: String.read(from: buf),
            backtrace: FfiConverterOptionString.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        message.write(into: buf)
        FfiConverterOptionString.write(backtrace, into: buf)
    }
}

extension ErrorDetails: ViaFfiUsingByteBuffer, ViaFfi {}

public struct StringString {
    public var i0: String
    public var i1: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(i0: String, i1: String) {
        self.i0 = i0
        self.i1 = i1
    }
}

extension StringString: Equatable, Hashable {
    public static func == (lhs: StringString, rhs: StringString) -> Bool {
        if lhs.i0 != rhs.i0 {
            return false
        }
        if lhs.i1 != rhs.i1 {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(i0)
        hasher.combine(i1)
    }
}

private extension StringString {
    static func read(from buf: Reader) throws -> StringString {
        return try StringString(
            i0: String.read(from: buf),
            i1: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        i0.write(into: buf)
        i1.write(into: buf)
    }
}

extension StringString: ViaFfiUsingByteBuffer, ViaFfi {}

public struct StringOptString {
    public var i0: String
    public var i1: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(i0: String, i1: String?) {
        self.i0 = i0
        self.i1 = i1
    }
}

extension StringOptString: Equatable, Hashable {
    public static func == (lhs: StringOptString, rhs: StringOptString) -> Bool {
        if lhs.i0 != rhs.i0 {
            return false
        }
        if lhs.i1 != rhs.i1 {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(i0)
        hasher.combine(i1)
    }
}

private extension StringOptString {
    static func read(from buf: Reader) throws -> StringOptString {
        return try StringOptString(
            i0: String.read(from: buf),
            i1: FfiConverterOptionString.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        i0.write(into: buf)
        FfiConverterOptionString.write(i1, into: buf)
    }
}

extension StringOptString: ViaFfiUsingByteBuffer, ViaFfi {}

public struct StringVecU8 {
    public var i0: String
    public var i1: [UInt8]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(i0: String, i1: [UInt8]) {
        self.i0 = i0
        self.i1 = i1
    }
}

extension StringVecU8: Equatable, Hashable {
    public static func == (lhs: StringVecU8, rhs: StringVecU8) -> Bool {
        if lhs.i0 != rhs.i0 {
            return false
        }
        if lhs.i1 != rhs.i1 {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(i0)
        hasher.combine(i1)
    }
}

private extension StringVecU8 {
    static func read(from buf: Reader) throws -> StringVecU8 {
        return try StringVecU8(
            i0: String.read(from: buf),
            i1: FfiConverterSequenceUInt8.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        i0.write(into: buf)
        FfiConverterSequenceUInt8.write(i1, into: buf)
    }
}

extension StringVecU8: ViaFfiUsingByteBuffer, ViaFfi {}

public struct StringStringU64 {
    public var i0: String
    public var i1: String
    public var i2: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(i0: String, i1: String, i2: UInt64) {
        self.i0 = i0
        self.i1 = i1
        self.i2 = i2
    }
}

extension StringStringU64: Equatable, Hashable {
    public static func == (lhs: StringStringU64, rhs: StringStringU64) -> Bool {
        if lhs.i0 != rhs.i0 {
            return false
        }
        if lhs.i1 != rhs.i1 {
            return false
        }
        if lhs.i2 != rhs.i2 {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(i0)
        hasher.combine(i1)
        hasher.combine(i2)
    }
}

private extension StringStringU64 {
    static func read(from buf: Reader) throws -> StringStringU64 {
        return try StringStringU64(
            i0: String.read(from: buf),
            i1: String.read(from: buf),
            i2: UInt64.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        i0.write(into: buf)
        i1.write(into: buf)
        i2.write(into: buf)
    }
}

extension StringStringU64: ViaFfiUsingByteBuffer, ViaFfi {}

public struct StringStringString {
    public var i0: String
    public var i1: String
    public var i2: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(i0: String, i1: String, i2: String) {
        self.i0 = i0
        self.i1 = i1
        self.i2 = i2
    }
}

extension StringStringString: Equatable, Hashable {
    public static func == (lhs: StringStringString, rhs: StringStringString) -> Bool {
        if lhs.i0 != rhs.i0 {
            return false
        }
        if lhs.i1 != rhs.i1 {
            return false
        }
        if lhs.i2 != rhs.i2 {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(i0)
        hasher.combine(i1)
        hasher.combine(i2)
    }
}

private extension StringStringString {
    static func read(from buf: Reader) throws -> StringStringString {
        return try StringStringString(
            i0: String.read(from: buf),
            i1: String.read(from: buf),
            i2: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        i0.write(into: buf)
        i1.write(into: buf)
        i2.write(into: buf)
    }
}

extension StringStringString: ViaFfiUsingByteBuffer, ViaFfi {}

public struct StringStringString122 {
    public var i0: String
    public var i1: String?
    public var i2: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(i0: String, i1: String?, i2: String?) {
        self.i0 = i0
        self.i1 = i1
        self.i2 = i2
    }
}

extension StringStringString122: Equatable, Hashable {
    public static func == (lhs: StringStringString122, rhs: StringStringString122) -> Bool {
        if lhs.i0 != rhs.i0 {
            return false
        }
        if lhs.i1 != rhs.i1 {
            return false
        }
        if lhs.i2 != rhs.i2 {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(i0)
        hasher.combine(i1)
        hasher.combine(i2)
    }
}

private extension StringStringString122 {
    static func read(from buf: Reader) throws -> StringStringString122 {
        return try StringStringString122(
            i0: String.read(from: buf),
            i1: FfiConverterOptionString.read(from: buf),
            i2: FfiConverterOptionString.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        i0.write(into: buf)
        FfiConverterOptionString.write(i1, into: buf)
        FfiConverterOptionString.write(i2, into: buf)
    }
}

extension StringStringString122: ViaFfiUsingByteBuffer, ViaFfi {}

public struct SearchHandleAndLength {
    public var i0: Int32
    public var i1: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(i0: Int32, i1: UInt64) {
        self.i0 = i0
        self.i1 = i1
    }
}

extension SearchHandleAndLength: Equatable, Hashable {
    public static func == (lhs: SearchHandleAndLength, rhs: SearchHandleAndLength) -> Bool {
        if lhs.i0 != rhs.i0 {
            return false
        }
        if lhs.i1 != rhs.i1 {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(i0)
        hasher.combine(i1)
    }
}

private extension SearchHandleAndLength {
    static func read(from buf: Reader) throws -> SearchHandleAndLength {
        return try SearchHandleAndLength(
            i0: Int32.read(from: buf),
            i1: UInt64.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        i0.write(into: buf)
        i1.write(into: buf)
    }
}

extension SearchHandleAndLength: ViaFfiUsingByteBuffer, ViaFfi {}

public enum ErrorCode {
    // Simple error enums only carry a message
    case Success(message: String)

    // Simple error enums only carry a message
    case CommonInvalidParam1(message: String)

    // Simple error enums only carry a message
    case CommonInvalidParam2(message: String)

    // Simple error enums only carry a message
    case CommonInvalidParam3(message: String)

    // Simple error enums only carry a message
    case CommonInvalidParam4(message: String)

    // Simple error enums only carry a message
    case CommonInvalidParam5(message: String)

    // Simple error enums only carry a message
    case CommonInvalidParam6(message: String)

    // Simple error enums only carry a message
    case CommonInvalidParam7(message: String)

    // Simple error enums only carry a message
    case CommonInvalidParam8(message: String)

    // Simple error enums only carry a message
    case CommonInvalidParam9(message: String)

    // Simple error enums only carry a message
    case CommonInvalidParam10(message: String)

    // Simple error enums only carry a message
    case CommonInvalidParam11(message: String)

    // Simple error enums only carry a message
    case CommonInvalidParam12(message: String)

    // Simple error enums only carry a message
    case CommonInvalidState(message: String)

    // Simple error enums only carry a message
    case CommonInvalidStructure(message: String)

    // Simple error enums only carry a message
    case CommonIoError(message: String)

    // Simple error enums only carry a message
    case CommonInvalidParam13(message: String)

    // Simple error enums only carry a message
    case CommonInvalidParam14(message: String)

    // Simple error enums only carry a message
    case CommonInvalidParam15(message: String)

    // Simple error enums only carry a message
    case CommonInvalidParam16(message: String)

    // Simple error enums only carry a message
    case CommonInvalidParam17(message: String)

    // Simple error enums only carry a message
    case CommonInvalidParam18(message: String)

    // Simple error enums only carry a message
    case CommonInvalidParam19(message: String)

    // Simple error enums only carry a message
    case CommonInvalidParam20(message: String)

    // Simple error enums only carry a message
    case CommonInvalidParam21(message: String)

    // Simple error enums only carry a message
    case CommonInvalidParam22(message: String)

    // Simple error enums only carry a message
    case CommonInvalidParam23(message: String)

    // Simple error enums only carry a message
    case CommonInvalidParam24(message: String)

    // Simple error enums only carry a message
    case CommonInvalidParam25(message: String)

    // Simple error enums only carry a message
    case CommonInvalidParam26(message: String)

    // Simple error enums only carry a message
    case CommonInvalidParam27(message: String)

    // Simple error enums only carry a message
    case WalletInvalidHandle(message: String)

    // Simple error enums only carry a message
    case WalletUnknownTypeError(message: String)

    // Simple error enums only carry a message
    case WalletTypeAlreadyRegisteredError(message: String)

    // Simple error enums only carry a message
    case WalletAlreadyExistsError(message: String)

    // Simple error enums only carry a message
    case WalletNotFoundError(message: String)

    // Simple error enums only carry a message
    case WalletIncompatiblePoolError(message: String)

    // Simple error enums only carry a message
    case WalletAlreadyOpenedError(message: String)

    // Simple error enums only carry a message
    case WalletAccessFailed(message: String)

    // Simple error enums only carry a message
    case WalletInputError(message: String)

    // Simple error enums only carry a message
    case WalletDecodingError(message: String)

    // Simple error enums only carry a message
    case WalletStorageError(message: String)

    // Simple error enums only carry a message
    case WalletEncryptionError(message: String)

    // Simple error enums only carry a message
    case WalletItemNotFound(message: String)

    // Simple error enums only carry a message
    case WalletItemAlreadyExists(message: String)

    // Simple error enums only carry a message
    case WalletQueryError(message: String)

    // Simple error enums only carry a message
    case PoolLedgerNotCreatedError(message: String)

    // Simple error enums only carry a message
    case PoolLedgerInvalidi32(message: String)

    // Simple error enums only carry a message
    case PoolLedgerTerminated(message: String)

    // Simple error enums only carry a message
    case LedgerNoConsensusError(message: String)

    // Simple error enums only carry a message
    case LedgerInvalidTransaction(message: String)

    // Simple error enums only carry a message
    case LedgerSecurityError(message: String)

    // Simple error enums only carry a message
    case PoolLedgerConfigAlreadyExistsError(message: String)

    // Simple error enums only carry a message
    case PoolLedgerTimeout(message: String)

    // Simple error enums only carry a message
    case PoolIncompatibleProtocolVersion(message: String)

    // Simple error enums only carry a message
    case LedgerNotFound(message: String)

    // Simple error enums only carry a message
    case AnoncredsRevocationRegistryFullError(message: String)

    // Simple error enums only carry a message
    case AnoncredsInvalidUserRevocId(message: String)

    // Simple error enums only carry a message
    case AnoncredsMasterSecretDuplicateNameError(message: String)

    // Simple error enums only carry a message
    case AnoncredsProofRejected(message: String)

    // Simple error enums only carry a message
    case AnoncredsCredentialRevoked(message: String)

    // Simple error enums only carry a message
    case AnoncredsCredDefAlreadyExistsError(message: String)

    // Simple error enums only carry a message
    case UnknownCryptoTypeError(message: String)

    // Simple error enums only carry a message
    case DidAlreadyExistsError(message: String)

    // Simple error enums only carry a message
    case UnknownPaymentMethod(message: String)

    // Simple error enums only carry a message
    case IncompatiblePaymentError(message: String)

    // Simple error enums only carry a message
    case PaymentInsufficientFundsError(message: String)

    // Simple error enums only carry a message
    case PaymentSourceDoesNotExistError(message: String)

    // Simple error enums only carry a message
    case PaymentOperationNotSupportedError(message: String)

    // Simple error enums only carry a message
    case PaymentExtraFundsError(message: String)

    // Simple error enums only carry a message
    case TransactionNotAllowed(message: String)
}

extension ErrorCode: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> ErrorCode {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .Success(
                message: try String.read(from: buf)
            )

        case 2: return .CommonInvalidParam1(
                message: try String.read(from: buf)
            )

        case 3: return .CommonInvalidParam2(
                message: try String.read(from: buf)
            )

        case 4: return .CommonInvalidParam3(
                message: try String.read(from: buf)
            )

        case 5: return .CommonInvalidParam4(
                message: try String.read(from: buf)
            )

        case 6: return .CommonInvalidParam5(
                message: try String.read(from: buf)
            )

        case 7: return .CommonInvalidParam6(
                message: try String.read(from: buf)
            )

        case 8: return .CommonInvalidParam7(
                message: try String.read(from: buf)
            )

        case 9: return .CommonInvalidParam8(
                message: try String.read(from: buf)
            )

        case 10: return .CommonInvalidParam9(
                message: try String.read(from: buf)
            )

        case 11: return .CommonInvalidParam10(
                message: try String.read(from: buf)
            )

        case 12: return .CommonInvalidParam11(
                message: try String.read(from: buf)
            )

        case 13: return .CommonInvalidParam12(
                message: try String.read(from: buf)
            )

        case 14: return .CommonInvalidState(
                message: try String.read(from: buf)
            )

        case 15: return .CommonInvalidStructure(
                message: try String.read(from: buf)
            )

        case 16: return .CommonIoError(
                message: try String.read(from: buf)
            )

        case 17: return .CommonInvalidParam13(
                message: try String.read(from: buf)
            )

        case 18: return .CommonInvalidParam14(
                message: try String.read(from: buf)
            )

        case 19: return .CommonInvalidParam15(
                message: try String.read(from: buf)
            )

        case 20: return .CommonInvalidParam16(
                message: try String.read(from: buf)
            )

        case 21: return .CommonInvalidParam17(
                message: try String.read(from: buf)
            )

        case 22: return .CommonInvalidParam18(
                message: try String.read(from: buf)
            )

        case 23: return .CommonInvalidParam19(
                message: try String.read(from: buf)
            )

        case 24: return .CommonInvalidParam20(
                message: try String.read(from: buf)
            )

        case 25: return .CommonInvalidParam21(
                message: try String.read(from: buf)
            )

        case 26: return .CommonInvalidParam22(
                message: try String.read(from: buf)
            )

        case 27: return .CommonInvalidParam23(
                message: try String.read(from: buf)
            )

        case 28: return .CommonInvalidParam24(
                message: try String.read(from: buf)
            )

        case 29: return .CommonInvalidParam25(
                message: try String.read(from: buf)
            )

        case 30: return .CommonInvalidParam26(
                message: try String.read(from: buf)
            )

        case 31: return .CommonInvalidParam27(
                message: try String.read(from: buf)
            )

        case 32: return .WalletInvalidHandle(
                message: try String.read(from: buf)
            )

        case 33: return .WalletUnknownTypeError(
                message: try String.read(from: buf)
            )

        case 34: return .WalletTypeAlreadyRegisteredError(
                message: try String.read(from: buf)
            )

        case 35: return .WalletAlreadyExistsError(
                message: try String.read(from: buf)
            )

        case 36: return .WalletNotFoundError(
                message: try String.read(from: buf)
            )

        case 37: return .WalletIncompatiblePoolError(
                message: try String.read(from: buf)
            )

        case 38: return .WalletAlreadyOpenedError(
                message: try String.read(from: buf)
            )

        case 39: return .WalletAccessFailed(
                message: try String.read(from: buf)
            )

        case 40: return .WalletInputError(
                message: try String.read(from: buf)
            )

        case 41: return .WalletDecodingError(
                message: try String.read(from: buf)
            )

        case 42: return .WalletStorageError(
                message: try String.read(from: buf)
            )

        case 43: return .WalletEncryptionError(
                message: try String.read(from: buf)
            )

        case 44: return .WalletItemNotFound(
                message: try String.read(from: buf)
            )

        case 45: return .WalletItemAlreadyExists(
                message: try String.read(from: buf)
            )

        case 46: return .WalletQueryError(
                message: try String.read(from: buf)
            )

        case 47: return .PoolLedgerNotCreatedError(
                message: try String.read(from: buf)
            )

        case 48: return .PoolLedgerInvalidi32(
                message: try String.read(from: buf)
            )

        case 49: return .PoolLedgerTerminated(
                message: try String.read(from: buf)
            )

        case 50: return .LedgerNoConsensusError(
                message: try String.read(from: buf)
            )

        case 51: return .LedgerInvalidTransaction(
                message: try String.read(from: buf)
            )

        case 52: return .LedgerSecurityError(
                message: try String.read(from: buf)
            )

        case 53: return .PoolLedgerConfigAlreadyExistsError(
                message: try String.read(from: buf)
            )

        case 54: return .PoolLedgerTimeout(
                message: try String.read(from: buf)
            )

        case 55: return .PoolIncompatibleProtocolVersion(
                message: try String.read(from: buf)
            )

        case 56: return .LedgerNotFound(
                message: try String.read(from: buf)
            )

        case 57: return .AnoncredsRevocationRegistryFullError(
                message: try String.read(from: buf)
            )

        case 58: return .AnoncredsInvalidUserRevocId(
                message: try String.read(from: buf)
            )

        case 59: return .AnoncredsMasterSecretDuplicateNameError(
                message: try String.read(from: buf)
            )

        case 60: return .AnoncredsProofRejected(
                message: try String.read(from: buf)
            )

        case 61: return .AnoncredsCredentialRevoked(
                message: try String.read(from: buf)
            )

        case 62: return .AnoncredsCredDefAlreadyExistsError(
                message: try String.read(from: buf)
            )

        case 63: return .UnknownCryptoTypeError(
                message: try String.read(from: buf)
            )

        case 64: return .DidAlreadyExistsError(
                message: try String.read(from: buf)
            )

        case 65: return .UnknownPaymentMethod(
                message: try String.read(from: buf)
            )

        case 66: return .IncompatiblePaymentError(
                message: try String.read(from: buf)
            )

        case 67: return .PaymentInsufficientFundsError(
                message: try String.read(from: buf)
            )

        case 68: return .PaymentSourceDoesNotExistError(
                message: try String.read(from: buf)
            )

        case 69: return .PaymentOperationNotSupportedError(
                message: try String.read(from: buf)
            )

        case 70: return .PaymentExtraFundsError(
                message: try String.read(from: buf)
            )

        case 71: return .TransactionNotAllowed(
                message: try String.read(from: buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        case let .Success(message):
            buf.writeInt(Int32(1))
            message.write(into: buf)
        case let .CommonInvalidParam1(message):
            buf.writeInt(Int32(2))
            message.write(into: buf)
        case let .CommonInvalidParam2(message):
            buf.writeInt(Int32(3))
            message.write(into: buf)
        case let .CommonInvalidParam3(message):
            buf.writeInt(Int32(4))
            message.write(into: buf)
        case let .CommonInvalidParam4(message):
            buf.writeInt(Int32(5))
            message.write(into: buf)
        case let .CommonInvalidParam5(message):
            buf.writeInt(Int32(6))
            message.write(into: buf)
        case let .CommonInvalidParam6(message):
            buf.writeInt(Int32(7))
            message.write(into: buf)
        case let .CommonInvalidParam7(message):
            buf.writeInt(Int32(8))
            message.write(into: buf)
        case let .CommonInvalidParam8(message):
            buf.writeInt(Int32(9))
            message.write(into: buf)
        case let .CommonInvalidParam9(message):
            buf.writeInt(Int32(10))
            message.write(into: buf)
        case let .CommonInvalidParam10(message):
            buf.writeInt(Int32(11))
            message.write(into: buf)
        case let .CommonInvalidParam11(message):
            buf.writeInt(Int32(12))
            message.write(into: buf)
        case let .CommonInvalidParam12(message):
            buf.writeInt(Int32(13))
            message.write(into: buf)
        case let .CommonInvalidState(message):
            buf.writeInt(Int32(14))
            message.write(into: buf)
        case let .CommonInvalidStructure(message):
            buf.writeInt(Int32(15))
            message.write(into: buf)
        case let .CommonIoError(message):
            buf.writeInt(Int32(16))
            message.write(into: buf)
        case let .CommonInvalidParam13(message):
            buf.writeInt(Int32(17))
            message.write(into: buf)
        case let .CommonInvalidParam14(message):
            buf.writeInt(Int32(18))
            message.write(into: buf)
        case let .CommonInvalidParam15(message):
            buf.writeInt(Int32(19))
            message.write(into: buf)
        case let .CommonInvalidParam16(message):
            buf.writeInt(Int32(20))
            message.write(into: buf)
        case let .CommonInvalidParam17(message):
            buf.writeInt(Int32(21))
            message.write(into: buf)
        case let .CommonInvalidParam18(message):
            buf.writeInt(Int32(22))
            message.write(into: buf)
        case let .CommonInvalidParam19(message):
            buf.writeInt(Int32(23))
            message.write(into: buf)
        case let .CommonInvalidParam20(message):
            buf.writeInt(Int32(24))
            message.write(into: buf)
        case let .CommonInvalidParam21(message):
            buf.writeInt(Int32(25))
            message.write(into: buf)
        case let .CommonInvalidParam22(message):
            buf.writeInt(Int32(26))
            message.write(into: buf)
        case let .CommonInvalidParam23(message):
            buf.writeInt(Int32(27))
            message.write(into: buf)
        case let .CommonInvalidParam24(message):
            buf.writeInt(Int32(28))
            message.write(into: buf)
        case let .CommonInvalidParam25(message):
            buf.writeInt(Int32(29))
            message.write(into: buf)
        case let .CommonInvalidParam26(message):
            buf.writeInt(Int32(30))
            message.write(into: buf)
        case let .CommonInvalidParam27(message):
            buf.writeInt(Int32(31))
            message.write(into: buf)
        case let .WalletInvalidHandle(message):
            buf.writeInt(Int32(32))
            message.write(into: buf)
        case let .WalletUnknownTypeError(message):
            buf.writeInt(Int32(33))
            message.write(into: buf)
        case let .WalletTypeAlreadyRegisteredError(message):
            buf.writeInt(Int32(34))
            message.write(into: buf)
        case let .WalletAlreadyExistsError(message):
            buf.writeInt(Int32(35))
            message.write(into: buf)
        case let .WalletNotFoundError(message):
            buf.writeInt(Int32(36))
            message.write(into: buf)
        case let .WalletIncompatiblePoolError(message):
            buf.writeInt(Int32(37))
            message.write(into: buf)
        case let .WalletAlreadyOpenedError(message):
            buf.writeInt(Int32(38))
            message.write(into: buf)
        case let .WalletAccessFailed(message):
            buf.writeInt(Int32(39))
            message.write(into: buf)
        case let .WalletInputError(message):
            buf.writeInt(Int32(40))
            message.write(into: buf)
        case let .WalletDecodingError(message):
            buf.writeInt(Int32(41))
            message.write(into: buf)
        case let .WalletStorageError(message):
            buf.writeInt(Int32(42))
            message.write(into: buf)
        case let .WalletEncryptionError(message):
            buf.writeInt(Int32(43))
            message.write(into: buf)
        case let .WalletItemNotFound(message):
            buf.writeInt(Int32(44))
            message.write(into: buf)
        case let .WalletItemAlreadyExists(message):
            buf.writeInt(Int32(45))
            message.write(into: buf)
        case let .WalletQueryError(message):
            buf.writeInt(Int32(46))
            message.write(into: buf)
        case let .PoolLedgerNotCreatedError(message):
            buf.writeInt(Int32(47))
            message.write(into: buf)
        case let .PoolLedgerInvalidi32(message):
            buf.writeInt(Int32(48))
            message.write(into: buf)
        case let .PoolLedgerTerminated(message):
            buf.writeInt(Int32(49))
            message.write(into: buf)
        case let .LedgerNoConsensusError(message):
            buf.writeInt(Int32(50))
            message.write(into: buf)
        case let .LedgerInvalidTransaction(message):
            buf.writeInt(Int32(51))
            message.write(into: buf)
        case let .LedgerSecurityError(message):
            buf.writeInt(Int32(52))
            message.write(into: buf)
        case let .PoolLedgerConfigAlreadyExistsError(message):
            buf.writeInt(Int32(53))
            message.write(into: buf)
        case let .PoolLedgerTimeout(message):
            buf.writeInt(Int32(54))
            message.write(into: buf)
        case let .PoolIncompatibleProtocolVersion(message):
            buf.writeInt(Int32(55))
            message.write(into: buf)
        case let .LedgerNotFound(message):
            buf.writeInt(Int32(56))
            message.write(into: buf)
        case let .AnoncredsRevocationRegistryFullError(message):
            buf.writeInt(Int32(57))
            message.write(into: buf)
        case let .AnoncredsInvalidUserRevocId(message):
            buf.writeInt(Int32(58))
            message.write(into: buf)
        case let .AnoncredsMasterSecretDuplicateNameError(message):
            buf.writeInt(Int32(59))
            message.write(into: buf)
        case let .AnoncredsProofRejected(message):
            buf.writeInt(Int32(60))
            message.write(into: buf)
        case let .AnoncredsCredentialRevoked(message):
            buf.writeInt(Int32(61))
            message.write(into: buf)
        case let .AnoncredsCredDefAlreadyExistsError(message):
            buf.writeInt(Int32(62))
            message.write(into: buf)
        case let .UnknownCryptoTypeError(message):
            buf.writeInt(Int32(63))
            message.write(into: buf)
        case let .DidAlreadyExistsError(message):
            buf.writeInt(Int32(64))
            message.write(into: buf)
        case let .UnknownPaymentMethod(message):
            buf.writeInt(Int32(65))
            message.write(into: buf)
        case let .IncompatiblePaymentError(message):
            buf.writeInt(Int32(66))
            message.write(into: buf)
        case let .PaymentInsufficientFundsError(message):
            buf.writeInt(Int32(67))
            message.write(into: buf)
        case let .PaymentSourceDoesNotExistError(message):
            buf.writeInt(Int32(68))
            message.write(into: buf)
        case let .PaymentOperationNotSupportedError(message):
            buf.writeInt(Int32(69))
            message.write(into: buf)
        case let .PaymentExtraFundsError(message):
            buf.writeInt(Int32(70))
            message.write(into: buf)
        case let .TransactionNotAllowed(message):
            buf.writeInt(Int32(71))
            message.write(into: buf)
        }
    }
}

extension ErrorCode: Equatable, Hashable {}

extension ErrorCode: Error {}

public enum IndyError2 {
    // Simple error enums only carry a message
    case ErrorResult(message: String)
}

extension IndyError2: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> IndyError2 {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .ErrorResult(
                message: try String.read(from: buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        case let .ErrorResult(message):
            buf.writeInt(Int32(1))
            message.write(into: buf)
        }
    }
}

extension IndyError2: Equatable, Hashable {}

extension IndyError2: Error {}
extension UInt8: Primitive, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> Self {
        return try lift(buf.readInt())
    }

    fileprivate func write(into buf: Writer) {
        buf.writeInt(lower())
    }
}

extension UInt32: Primitive, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> Self {
        return try lift(buf.readInt())
    }

    fileprivate func write(into buf: Writer) {
        buf.writeInt(lower())
    }
}

extension Int32: Primitive, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> Self {
        return try lift(buf.readInt())
    }

    fileprivate func write(into buf: Writer) {
        buf.writeInt(lower())
    }
}

extension UInt64: Primitive, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> Self {
        return try lift(buf.readInt())
    }

    fileprivate func write(into buf: Writer) {
        buf.writeInt(lower())
    }
}

extension Int64: Primitive, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> Self {
        return try lift(buf.readInt())
    }

    fileprivate func write(into buf: Writer) {
        buf.writeInt(lower())
    }
}

extension Bool: ViaFfi {
    fileprivate typealias FfiType = Int8

    fileprivate static func read(from buf: Reader) throws -> Self {
        return try lift(buf.readInt())
    }

    fileprivate func write(into buf: Writer) {
        buf.writeInt(lower())
    }

    fileprivate static func lift(_ v: FfiType) throws -> Self {
        return v != 0
    }

    fileprivate func lower() -> FfiType {
        return self ? 1 : 0
    }
}

extension String: ViaFfi {
    fileprivate typealias FfiType = RustBuffer

    fileprivate static func lift(_ v: FfiType) throws -> Self {
        defer {
            v.deallocate()
        }
        if v.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: v.data!, count: Int(v.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    fileprivate func lower() -> FfiType {
        return utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    fileprivate static func read(from buf: Reader) throws -> Self {
        let len: Int32 = try buf.readInt()
        return String(bytes: try buf.readBytes(count: Int(len)), encoding: String.Encoding.utf8)!
    }

    fileprivate func write(into buf: Writer) {
        let len = Int32(utf8.count)
        buf.writeInt(len)
        buf.writeBytes(utf8)
    }
}

// Helper code for ErrorDetails record is found in RecordTemplate.swift
// Helper code for IndyError record is found in RecordTemplate.swift
// Helper code for SearchHandleAndLength record is found in RecordTemplate.swift
// Helper code for StringOptString record is found in RecordTemplate.swift
// Helper code for StringString record is found in RecordTemplate.swift
// Helper code for StringStringString record is found in RecordTemplate.swift
// Helper code for StringStringString122 record is found in RecordTemplate.swift
// Helper code for StringStringU64 record is found in RecordTemplate.swift
// Helper code for StringVecU8 record is found in RecordTemplate.swift
// Helper code for ErrorCode error is found in ErrorTemplate.swift
// Helper code for IndyError2 error is found in ErrorTemplate.swift

private enum FfiConverterOptionUInt64: FfiConverterUsingByteBuffer {
    typealias SwiftType = UInt64?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try UInt64.read(from: buf)
        }
    }
}

private enum FfiConverterOptionString: FfiConverterUsingByteBuffer {
    typealias SwiftType = String?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try String.read(from: buf)
        }
    }
}

private enum FfiConverterSequenceUInt8: FfiConverterUsingByteBuffer {
    typealias SwiftType = [UInt8]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try UInt8.read(from: buf)
        }
    }
}

private enum FfiConverterSequenceUInt64: FfiConverterUsingByteBuffer {
    typealias SwiftType = [UInt64]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try UInt64.read(from: buf)
        }
    }
}

/**
 * Top level initializers and tear down methods.
 *
 * This is generated by uniffi.
 */
public enum LibLifecycle {
    /**
     * Initialize the FFI and Rust library. This should be only called once per application.
     */
    func initialize() {
        // No initialization code needed
    }
}
