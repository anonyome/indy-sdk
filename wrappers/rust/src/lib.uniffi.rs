// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// Check for compatibility between `uniffi` and `uniffi_bindgen` versions.
// Note that we have an error message on the same line as the assertion.
// This is important, because if the assertion fails, the compiler only
// seems to show that single line as context for the user.
uniffi::assert_compatible_version!("0.16.0"); // Please check that you depend on version 0.16.0 of the `uniffi` crate.

// Everybody gets basic buffer support, since it's needed for passing complex types over the FFI.

/// This helper allocates a new byte buffer owned by the Rust code, and returns it
/// to the foreign-language code as a `RustBuffer` struct. Callers must eventually
/// free the resulting buffer, either by explicitly calling the destructor defined below,
/// or by passing ownership of the buffer back into Rust code.
#[doc(hidden)]
#[no_mangle]
pub extern "C" fn ffi_lib_2f6d_rustbuffer_alloc(
    size: i32,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    uniffi::call_with_output(call_status, || {
        uniffi::RustBuffer::new_with_size(size.max(0) as usize)
    })
}

/// This helper copies bytes owned by the foreign-language code into a new byte buffer owned
/// by the Rust code, and returns it as a `RustBuffer` struct. Callers must eventually
/// free the resulting buffer, either by explicitly calling the destructor defined below,
/// or by passing ownership of the buffer back into Rust code.
///
/// # Safety
/// This function will dereference a provided pointer in order to copy bytes from it, so
/// make sure the `ForeignBytes` struct contains a valid pointer and length.
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_lib_2f6d_rustbuffer_from_bytes(
    bytes: uniffi::ForeignBytes,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    uniffi::call_with_output(call_status, || {
        let bytes = bytes.as_slice();
        uniffi::RustBuffer::from_vec(bytes.to_vec())
    })
}

/// Free a byte buffer that had previously been passed to the foreign language code.
///
/// # Safety
/// The argument *must* be a uniquely-owned `RustBuffer` previously obtained from a call
/// into the Rust code that returned a buffer, or you'll risk freeing unowned memory or
/// corrupting the allocator state.
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_lib_2f6d_rustbuffer_free(
    buf: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) {
    uniffi::call_with_output(call_status, || uniffi::RustBuffer::destroy(buf))
}

/// Reserve additional capacity in a byte buffer that had previously been passed to the
/// foreign language code.
///
/// The first argument *must* be a uniquely-owned `RustBuffer` previously
/// obtained from a call into the Rust code that returned a buffer. Its underlying data pointer
/// will be reallocated if necessary and returned in a new `RustBuffer` struct.
///
/// The second argument must be the minimum number of *additional* bytes to reserve
/// capacity for in the buffer; it is likely to reserve additional capacity in practice
/// due to amortized growth strategy of Rust vectors.
///
/// # Safety
/// The first argument *must* be a uniquely-owned `RustBuffer` previously obtained from a call
/// into the Rust code that returned a buffer, or you'll risk freeing unowned memory or
/// corrupting the allocator state.
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_lib_2f6d_rustbuffer_reserve(
    buf: uniffi::RustBuffer,
    additional: i32,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    uniffi::call_with_output(call_status, || {
        use std::convert::TryInto;
        let additional: usize = additional
            .try_into()
            .expect("additional buffer length negative or overflowed");
        let mut v = buf.destroy_into_vec();
        v.reserve(additional);
        uniffi::RustBuffer::from_vec(v)
    })
}

// Error definitions, corresponding to `error` in the UDL.

#[doc(hidden)]
pub struct FfiConverterTypeErrorCode;

#[doc(hidden)]
impl uniffi::RustBufferFfiConverter for FfiConverterTypeErrorCode {
    type RustType = ErrorCode;

    // For "flat" error enums, we stringify the error on the Rust side and surface that
    // as the error message in the foreign language.

    fn write(obj: ErrorCode, buf: &mut std::vec::Vec<u8>) {
        use uniffi::deps::bytes::BufMut;
        let msg = obj.to_string();
        match obj {
            ErrorCode::Success { .. } => {
                buf.put_i32(1);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::CommonInvalidParam1 { .. } => {
                buf.put_i32(2);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::CommonInvalidParam2 { .. } => {
                buf.put_i32(3);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::CommonInvalidParam3 { .. } => {
                buf.put_i32(4);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::CommonInvalidParam4 { .. } => {
                buf.put_i32(5);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::CommonInvalidParam5 { .. } => {
                buf.put_i32(6);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::CommonInvalidParam6 { .. } => {
                buf.put_i32(7);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::CommonInvalidParam7 { .. } => {
                buf.put_i32(8);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::CommonInvalidParam8 { .. } => {
                buf.put_i32(9);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::CommonInvalidParam9 { .. } => {
                buf.put_i32(10);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::CommonInvalidParam10 { .. } => {
                buf.put_i32(11);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::CommonInvalidParam11 { .. } => {
                buf.put_i32(12);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::CommonInvalidParam12 { .. } => {
                buf.put_i32(13);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::CommonInvalidState { .. } => {
                buf.put_i32(14);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::CommonInvalidStructure { .. } => {
                buf.put_i32(15);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::CommonIOError { .. } => {
                buf.put_i32(16);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::CommonInvalidParam13 { .. } => {
                buf.put_i32(17);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::CommonInvalidParam14 { .. } => {
                buf.put_i32(18);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::CommonInvalidParam15 { .. } => {
                buf.put_i32(19);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::CommonInvalidParam16 { .. } => {
                buf.put_i32(20);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::CommonInvalidParam17 { .. } => {
                buf.put_i32(21);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::CommonInvalidParam18 { .. } => {
                buf.put_i32(22);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::CommonInvalidParam19 { .. } => {
                buf.put_i32(23);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::CommonInvalidParam20 { .. } => {
                buf.put_i32(24);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::CommonInvalidParam21 { .. } => {
                buf.put_i32(25);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::CommonInvalidParam22 { .. } => {
                buf.put_i32(26);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::CommonInvalidParam23 { .. } => {
                buf.put_i32(27);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::CommonInvalidParam24 { .. } => {
                buf.put_i32(28);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::CommonInvalidParam25 { .. } => {
                buf.put_i32(29);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::CommonInvalidParam26 { .. } => {
                buf.put_i32(30);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::CommonInvalidParam27 { .. } => {
                buf.put_i32(31);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::WalletInvalidHandle { .. } => {
                buf.put_i32(32);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::WalletUnknownTypeError { .. } => {
                buf.put_i32(33);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::WalletTypeAlreadyRegisteredError { .. } => {
                buf.put_i32(34);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::WalletAlreadyExistsError { .. } => {
                buf.put_i32(35);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::WalletNotFoundError { .. } => {
                buf.put_i32(36);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::WalletIncompatiblePoolError { .. } => {
                buf.put_i32(37);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::WalletAlreadyOpenedError { .. } => {
                buf.put_i32(38);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::WalletAccessFailed { .. } => {
                buf.put_i32(39);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::WalletInputError { .. } => {
                buf.put_i32(40);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::WalletDecodingError { .. } => {
                buf.put_i32(41);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::WalletStorageError { .. } => {
                buf.put_i32(42);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::WalletEncryptionError { .. } => {
                buf.put_i32(43);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::WalletItemNotFound { .. } => {
                buf.put_i32(44);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::WalletItemAlreadyExists { .. } => {
                buf.put_i32(45);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::WalletQueryError { .. } => {
                buf.put_i32(46);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::PoolLedgerNotCreatedError { .. } => {
                buf.put_i32(47);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::PoolLedgerInvalidi32 { .. } => {
                buf.put_i32(48);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::PoolLedgerTerminated { .. } => {
                buf.put_i32(49);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::LedgerNoConsensusError { .. } => {
                buf.put_i32(50);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::LedgerInvalidTransaction { .. } => {
                buf.put_i32(51);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::LedgerSecurityError { .. } => {
                buf.put_i32(52);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::PoolLedgerConfigAlreadyExistsError { .. } => {
                buf.put_i32(53);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::PoolLedgerTimeout { .. } => {
                buf.put_i32(54);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::PoolIncompatibleProtocolVersion { .. } => {
                buf.put_i32(55);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::LedgerNotFound { .. } => {
                buf.put_i32(56);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::AnoncredsRevocationRegistryFullError { .. } => {
                buf.put_i32(57);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::AnoncredsInvalidUserRevocId { .. } => {
                buf.put_i32(58);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::AnoncredsMasterSecretDuplicateNameError { .. } => {
                buf.put_i32(59);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::AnoncredsProofRejected { .. } => {
                buf.put_i32(60);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::AnoncredsCredentialRevoked { .. } => {
                buf.put_i32(61);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::AnoncredsCredDefAlreadyExistsError { .. } => {
                buf.put_i32(62);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::UnknownCryptoTypeError { .. } => {
                buf.put_i32(63);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::DidAlreadyExistsError { .. } => {
                buf.put_i32(64);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::UnknownPaymentMethod { .. } => {
                buf.put_i32(65);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::IncompatiblePaymentError { .. } => {
                buf.put_i32(66);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::PaymentInsufficientFundsError { .. } => {
                buf.put_i32(67);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::PaymentSourceDoesNotExistError { .. } => {
                buf.put_i32(68);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::PaymentOperationNotSupportedError { .. } => {
                buf.put_i32(69);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::PaymentExtraFundsError { .. } => {
                buf.put_i32(70);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            ErrorCode::TransactionNotAllowed { .. } => {
                buf.put_i32(71);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
        };
    }

    fn try_read(_buf: &mut &[u8]) -> uniffi::deps::anyhow::Result<ErrorCode> {
        // It's not currently possible to send errors from the foreign language *into* Rust.
        panic!("try_read not supported for flat errors");
    }
}

impl uniffi::FfiError for FfiConverterTypeErrorCode {}

#[doc(hidden)]
pub struct FfiConverterTypeIndyError2;

#[doc(hidden)]
impl uniffi::RustBufferFfiConverter for FfiConverterTypeIndyError2 {
    type RustType = IndyError2;

    // For "flat" error enums, we stringify the error on the Rust side and surface that
    // as the error message in the foreign language.

    fn write(obj: IndyError2, buf: &mut std::vec::Vec<u8>) {
        use uniffi::deps::bytes::BufMut;
        let msg = obj.to_string();
        match obj {
            IndyError2::ErrorResult { .. } => {
                buf.put_i32(1);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
        };
    }

    fn try_read(_buf: &mut &[u8]) -> uniffi::deps::anyhow::Result<IndyError2> {
        // It's not currently possible to send errors from the foreign language *into* Rust.
        panic!("try_read not supported for flat errors");
    }
}

impl uniffi::FfiError for FfiConverterTypeIndyError2 {}

// Enum defitions, corresponding to `enum` in UDL.

// Record definitions, implemented as method-less structs, corresponding to `dictionary` objects.

#[doc(hidden)]
pub struct FfiConverterTypeIndyError;

#[doc(hidden)]
impl uniffi::RustBufferFfiConverter for FfiConverterTypeIndyError {
    type RustType = IndyError;

    fn write(obj: IndyError, buf: &mut std::vec::Vec<u8>) {
        // If the provided struct doesn't match the fields declared in the UDL, then
        // the generated code here will fail to compile with somewhat helpful error.
        <FfiConverterTypeErrorCode as uniffi::FfiConverter>::write(obj.error_code, buf);
        <String as uniffi::FfiConverter>::write(obj.message, buf);
        <std::option::Option<String> as uniffi::FfiConverter>::write(obj.indy_backtrace, buf);
    }

    fn try_read(buf: &mut &[u8]) -> uniffi::deps::anyhow::Result<IndyError> {
        Ok(IndyError {
            error_code: <FfiConverterTypeErrorCode as uniffi::FfiConverter>::try_read(buf)?,
            message: <String as uniffi::FfiConverter>::try_read(buf)?,
            indy_backtrace: <std::option::Option<String> as uniffi::FfiConverter>::try_read(buf)?,
        })
    }
}

#[doc(hidden)]
pub struct FfiConverterTypeErrorDetails;

#[doc(hidden)]
impl uniffi::RustBufferFfiConverter for FfiConverterTypeErrorDetails {
    type RustType = ErrorDetails;

    fn write(obj: ErrorDetails, buf: &mut std::vec::Vec<u8>) {
        // If the provided struct doesn't match the fields declared in the UDL, then
        // the generated code here will fail to compile with somewhat helpful error.
        <String as uniffi::FfiConverter>::write(obj.message, buf);
        <std::option::Option<String> as uniffi::FfiConverter>::write(obj.backtrace, buf);
    }

    fn try_read(buf: &mut &[u8]) -> uniffi::deps::anyhow::Result<ErrorDetails> {
        Ok(ErrorDetails {
            message: <String as uniffi::FfiConverter>::try_read(buf)?,
            backtrace: <std::option::Option<String> as uniffi::FfiConverter>::try_read(buf)?,
        })
    }
}

#[doc(hidden)]
pub struct FfiConverterTypeStringString;

#[doc(hidden)]
impl uniffi::RustBufferFfiConverter for FfiConverterTypeStringString {
    type RustType = StringString;

    fn write(obj: StringString, buf: &mut std::vec::Vec<u8>) {
        // If the provided struct doesn't match the fields declared in the UDL, then
        // the generated code here will fail to compile with somewhat helpful error.
        <String as uniffi::FfiConverter>::write(obj.i0, buf);
        <String as uniffi::FfiConverter>::write(obj.i1, buf);
    }

    fn try_read(buf: &mut &[u8]) -> uniffi::deps::anyhow::Result<StringString> {
        Ok(StringString {
            i0: <String as uniffi::FfiConverter>::try_read(buf)?,
            i1: <String as uniffi::FfiConverter>::try_read(buf)?,
        })
    }
}

#[doc(hidden)]
pub struct FfiConverterTypeStringOptString;

#[doc(hidden)]
impl uniffi::RustBufferFfiConverter for FfiConverterTypeStringOptString {
    type RustType = StringOptString;

    fn write(obj: StringOptString, buf: &mut std::vec::Vec<u8>) {
        // If the provided struct doesn't match the fields declared in the UDL, then
        // the generated code here will fail to compile with somewhat helpful error.
        <String as uniffi::FfiConverter>::write(obj.i0, buf);
        <std::option::Option<String> as uniffi::FfiConverter>::write(obj.i1, buf);
    }

    fn try_read(buf: &mut &[u8]) -> uniffi::deps::anyhow::Result<StringOptString> {
        Ok(StringOptString {
            i0: <String as uniffi::FfiConverter>::try_read(buf)?,
            i1: <std::option::Option<String> as uniffi::FfiConverter>::try_read(buf)?,
        })
    }
}

#[doc(hidden)]
pub struct FfiConverterTypeStringVecU8;

#[doc(hidden)]
impl uniffi::RustBufferFfiConverter for FfiConverterTypeStringVecU8 {
    type RustType = StringVecU8;

    fn write(obj: StringVecU8, buf: &mut std::vec::Vec<u8>) {
        // If the provided struct doesn't match the fields declared in the UDL, then
        // the generated code here will fail to compile with somewhat helpful error.
        <String as uniffi::FfiConverter>::write(obj.i0, buf);
        <std::vec::Vec<u8> as uniffi::FfiConverter>::write(obj.i1, buf);
    }

    fn try_read(buf: &mut &[u8]) -> uniffi::deps::anyhow::Result<StringVecU8> {
        Ok(StringVecU8 {
            i0: <String as uniffi::FfiConverter>::try_read(buf)?,
            i1: <std::vec::Vec<u8> as uniffi::FfiConverter>::try_read(buf)?,
        })
    }
}

#[doc(hidden)]
pub struct FfiConverterTypeStringStringU64;

#[doc(hidden)]
impl uniffi::RustBufferFfiConverter for FfiConverterTypeStringStringU64 {
    type RustType = StringStringU64;

    fn write(obj: StringStringU64, buf: &mut std::vec::Vec<u8>) {
        // If the provided struct doesn't match the fields declared in the UDL, then
        // the generated code here will fail to compile with somewhat helpful error.
        <String as uniffi::FfiConverter>::write(obj.i0, buf);
        <String as uniffi::FfiConverter>::write(obj.i1, buf);
        <u64 as uniffi::FfiConverter>::write(obj.i2, buf);
    }

    fn try_read(buf: &mut &[u8]) -> uniffi::deps::anyhow::Result<StringStringU64> {
        Ok(StringStringU64 {
            i0: <String as uniffi::FfiConverter>::try_read(buf)?,
            i1: <String as uniffi::FfiConverter>::try_read(buf)?,
            i2: <u64 as uniffi::FfiConverter>::try_read(buf)?,
        })
    }
}

#[doc(hidden)]
pub struct FfiConverterTypeStringStringString;

#[doc(hidden)]
impl uniffi::RustBufferFfiConverter for FfiConverterTypeStringStringString {
    type RustType = StringStringString;

    fn write(obj: StringStringString, buf: &mut std::vec::Vec<u8>) {
        // If the provided struct doesn't match the fields declared in the UDL, then
        // the generated code here will fail to compile with somewhat helpful error.
        <String as uniffi::FfiConverter>::write(obj.i0, buf);
        <String as uniffi::FfiConverter>::write(obj.i1, buf);
        <String as uniffi::FfiConverter>::write(obj.i2, buf);
    }

    fn try_read(buf: &mut &[u8]) -> uniffi::deps::anyhow::Result<StringStringString> {
        Ok(StringStringString {
            i0: <String as uniffi::FfiConverter>::try_read(buf)?,
            i1: <String as uniffi::FfiConverter>::try_read(buf)?,
            i2: <String as uniffi::FfiConverter>::try_read(buf)?,
        })
    }
}

#[doc(hidden)]
pub struct FfiConverterTypeStringStringString122;

#[doc(hidden)]
impl uniffi::RustBufferFfiConverter for FfiConverterTypeStringStringString122 {
    type RustType = StringStringString122;

    fn write(obj: StringStringString122, buf: &mut std::vec::Vec<u8>) {
        // If the provided struct doesn't match the fields declared in the UDL, then
        // the generated code here will fail to compile with somewhat helpful error.
        <String as uniffi::FfiConverter>::write(obj.i0, buf);
        <std::option::Option<String> as uniffi::FfiConverter>::write(obj.i1, buf);
        <std::option::Option<String> as uniffi::FfiConverter>::write(obj.i2, buf);
    }

    fn try_read(buf: &mut &[u8]) -> uniffi::deps::anyhow::Result<StringStringString122> {
        Ok(StringStringString122 {
            i0: <String as uniffi::FfiConverter>::try_read(buf)?,
            i1: <std::option::Option<String> as uniffi::FfiConverter>::try_read(buf)?,
            i2: <std::option::Option<String> as uniffi::FfiConverter>::try_read(buf)?,
        })
    }
}

#[doc(hidden)]
pub struct FfiConverterTypeSearchHandleAndLength;

#[doc(hidden)]
impl uniffi::RustBufferFfiConverter for FfiConverterTypeSearchHandleAndLength {
    type RustType = SearchHandleAndLength;

    fn write(obj: SearchHandleAndLength, buf: &mut std::vec::Vec<u8>) {
        // If the provided struct doesn't match the fields declared in the UDL, then
        // the generated code here will fail to compile with somewhat helpful error.
        <i32 as uniffi::FfiConverter>::write(obj.i0, buf);
        <u64 as uniffi::FfiConverter>::write(obj.i1, buf);
    }

    fn try_read(buf: &mut &[u8]) -> uniffi::deps::anyhow::Result<SearchHandleAndLength> {
        Ok(SearchHandleAndLength {
            i0: <i32 as uniffi::FfiConverter>::try_read(buf)?,
            i1: <u64 as uniffi::FfiConverter>::try_read(buf)?,
        })
    }
}

// Top level functions, corresponding to UDL `namespace` functions.

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_set_runtime_config(
    config: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_set_runtime_config");

    uniffi::call_with_output(call_status, || {
        <FfiConverterTypeErrorCode as uniffi::FfiConverter>::lower(set_runtime_config(
            match <String as uniffi::FfiConverter>::try_lift(config) {
                Ok(ref val) => val,

                Err(err) => panic!("Failed to convert arg '{}': {}", "config", err),
            },
        ))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_open_reader(
    xtype: uniffi::RustBuffer,
    config_json: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> i32 {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_open_reader");

    uniffi::call_with_result(call_status, || {
        let _retval = open_reader(
            match <String as uniffi::FfiConverter>::try_lift(xtype) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "xtype"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(config_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "config_json"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<i32 as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_open_writer(
    xtype: uniffi::RustBuffer,
    config_json: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> i32 {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_open_writer");

    uniffi::call_with_result(call_status, || {
        let _retval = open_writer(
            match <String as uniffi::FfiConverter>::try_lift(xtype) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "xtype"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(config_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "config_json"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<i32 as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_register_wallet_storage(
    xtype: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_register_wallet_storage");

    uniffi::call_with_result(call_status, || {
        let _retval =
            register_wallet_storage(match <String as uniffi::FfiConverter>::try_lift(xtype) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "xtype"))
                }
            })
            .map_err(Into::into)
            .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(_retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_create_wallet(
    config: uniffi::RustBuffer,
    credentials: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_create_wallet");

    uniffi::call_with_result(call_status, || {
        let _retval = create_wallet(
            match <String as uniffi::FfiConverter>::try_lift(config) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "config"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(credentials) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "credentials"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(_retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_open_wallet(
    config: uniffi::RustBuffer,
    credentials: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> i32 {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_open_wallet");

    uniffi::call_with_result(call_status, || {
        let _retval = open_wallet(
            match <String as uniffi::FfiConverter>::try_lift(config) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "config"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(credentials) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "credentials"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<i32 as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_export_wallet(
    wallet_handle: i32,
    export_config: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_export_wallet");

    uniffi::call_with_result(call_status, || {
        let _retval = export_wallet(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(export_config) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "export_config"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(_retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_import_wallet(
    config: uniffi::RustBuffer,
    credentials: uniffi::RustBuffer,
    import_config: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_import_wallet");

    uniffi::call_with_result(call_status, || {
        let _retval = import_wallet(
            match <String as uniffi::FfiConverter>::try_lift(config) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "config"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(credentials) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "credentials"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(import_config) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "import_config"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(_retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_delete_wallet(
    config: uniffi::RustBuffer,
    credentials: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_delete_wallet");

    uniffi::call_with_result(call_status, || {
        let _retval = delete_wallet(
            match <String as uniffi::FfiConverter>::try_lift(config) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "config"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(credentials) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "credentials"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(_retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_close_wallet(
    wallet_handle: i32,
    call_status: &mut uniffi::RustCallStatus,
) {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_close_wallet");

    uniffi::call_with_result(call_status, || {
        let _retval = close_wallet(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(_retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_add_wallet_record(
    wallet_handle: i32,
    xtype: uniffi::RustBuffer,
    id: uniffi::RustBuffer,
    value: uniffi::RustBuffer,
    tags_json: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_add_wallet_record");

    uniffi::call_with_result(call_status, || {
        let _retval = add_wallet_record(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(xtype) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "xtype"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(id) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "id"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(value) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "value"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(tags_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "tags_json"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(_retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_update_wallet_record_value(
    wallet_handle: i32,
    xtype: uniffi::RustBuffer,
    id: uniffi::RustBuffer,
    value: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_update_wallet_record_value");

    uniffi::call_with_result(call_status, || {
        let _retval = update_wallet_record_value(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(xtype) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "xtype"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(id) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "id"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(value) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "value"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(_retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_update_wallet_record_tags(
    wallet_handle: i32,
    xtype: uniffi::RustBuffer,
    id: uniffi::RustBuffer,
    tags_json: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_update_wallet_record_tags");

    uniffi::call_with_result(call_status, || {
        let _retval = update_wallet_record_tags(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(xtype) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "xtype"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(id) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "id"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(tags_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "tags_json"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(_retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_add_wallet_record_tags(
    wallet_handle: i32,
    xtype: uniffi::RustBuffer,
    id: uniffi::RustBuffer,
    tags_json: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_add_wallet_record_tags");

    uniffi::call_with_result(call_status, || {
        let _retval = add_wallet_record_tags(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(xtype) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "xtype"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(id) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "id"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(tags_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "tags_json"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(_retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_delete_wallet_record_tags(
    wallet_handle: i32,
    xtype: uniffi::RustBuffer,
    id: uniffi::RustBuffer,
    tag_names_json: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_delete_wallet_record_tags");

    uniffi::call_with_result(call_status, || {
        let _retval = delete_wallet_record_tags(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(xtype) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "xtype"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(id) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "id"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(tag_names_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "tag_names_json"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(_retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_delete_wallet_record(
    wallet_handle: i32,
    xtype: uniffi::RustBuffer,
    id: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_delete_wallet_record");

    uniffi::call_with_result(call_status, || {
        let _retval = delete_wallet_record(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(xtype) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "xtype"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(id) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "id"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(_retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_get_wallet_record(
    wallet_handle: i32,
    xtype: uniffi::RustBuffer,
    id: uniffi::RustBuffer,
    options_json: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_get_wallet_record");

    uniffi::call_with_result(call_status, || {
        let _retval = get_wallet_record(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(xtype) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "xtype"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(id) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "id"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(options_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "options_json"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_open_wallet_search(
    wallet_handle: i32,
    xtype: uniffi::RustBuffer,
    query_json: uniffi::RustBuffer,
    options_json: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> i32 {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_open_wallet_search");

    uniffi::call_with_result(call_status, || {
        let _retval = open_wallet_search(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(xtype) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "xtype"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(query_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "query_json"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(options_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "options_json"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<i32 as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_fetch_wallet_search_next_records(
    wallet_handle: i32,
    wallet_search_handle: i32,
    count: u64,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_fetch_wallet_search_next_records");

    uniffi::call_with_result(call_status, || {
        let _retval = fetch_wallet_search_next_records(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_search_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_search_handle"))
                }
            },
            match <u64 as uniffi::FfiConverter>::try_lift(count) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "count"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_close_wallet_search(
    wallet_search_handle: i32,
    call_status: &mut uniffi::RustCallStatus,
) {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_close_wallet_search");

    uniffi::call_with_result(call_status, || {
        let _retval = close_wallet_search(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_search_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_search_handle"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(_retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_generate_wallet_key(
    config: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_generate_wallet_key");

    uniffi::call_with_result(call_status, || {
        let _retval =
            generate_wallet_key(match <String as uniffi::FfiConverter>::try_lift(config) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "config"))
                }
            })
            .map_err(Into::into)
            .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_create_pool_ledger_config(
    pool_name: uniffi::RustBuffer,
    pool_config: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_create_pool_ledger_config");

    uniffi::call_with_result(call_status, || {
        let _retval = create_pool_ledger_config(
            match <String as uniffi::FfiConverter>::try_lift(pool_name) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "pool_name"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(pool_config) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "pool_config"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(_retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_open_pool_ledger(
    pool_name: uniffi::RustBuffer,
    config: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> i32 {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_open_pool_ledger");

    uniffi::call_with_result(call_status, || {
        let _retval = open_pool_ledger(
            match <String as uniffi::FfiConverter>::try_lift(pool_name) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "pool_name"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(config) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "config"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<i32 as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_refresh_pool_ledger(
    pool_handle: i32,
    call_status: &mut uniffi::RustCallStatus,
) {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_refresh_pool_ledger");

    uniffi::call_with_result(call_status, || {
        let _retval =
            refresh_pool_ledger(match <i32 as uniffi::FfiConverter>::try_lift(pool_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "pool_handle"))
                }
            })
            .map_err(Into::into)
            .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(_retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_list_pools(
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_list_pools");

    uniffi::call_with_result(call_status, || {
        let _retval = list_pools()
            .map_err(Into::into)
            .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_close_pool_ledger(
    pool_handle: i32,
    call_status: &mut uniffi::RustCallStatus,
) {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_close_pool_ledger");

    uniffi::call_with_result(call_status, || {
        let _retval =
            close_pool_ledger(match <i32 as uniffi::FfiConverter>::try_lift(pool_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "pool_handle"))
                }
            })
            .map_err(Into::into)
            .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(_retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_delete_pool_ledger(
    pool_name: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_delete_pool_ledger");

    uniffi::call_with_result(call_status, || {
        let _retval = delete_pool_ledger(
            match <String as uniffi::FfiConverter>::try_lift(pool_name) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "pool_name"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(_retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_set_protocol_version(
    protocol_version: u64,
    call_status: &mut uniffi::RustCallStatus,
) {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_set_protocol_version");

    uniffi::call_with_result(call_status, || {
        let _retval = set_protocol_version(
            match <u64 as uniffi::FfiConverter>::try_lift(protocol_version) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "protocol_version"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(_retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_create_and_store_my_did(
    wallet_handle: i32,
    did_json: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_create_and_store_my_did");

    uniffi::call_with_result(call_status, || {
        let _retval = create_and_store_my_did(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(did_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "did_json"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<FfiConverterTypeStringString as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_replace_keys_start(
    wallet_handle: i32,
    tgt_did: uniffi::RustBuffer,
    identity_json: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_replace_keys_start");

    uniffi::call_with_result(call_status, || {
        let _retval = replace_keys_start(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(tgt_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "tgt_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(identity_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "identity_json"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_replace_keys_apply(
    wallet_handle: i32,
    tgt_did: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_replace_keys_apply");

    uniffi::call_with_result(call_status, || {
        let _retval = replace_keys_apply(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(tgt_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "tgt_did"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(_retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_store_their_did(
    wallet_handle: i32,
    identity_json: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_store_their_did");

    uniffi::call_with_result(call_status, || {
        let _retval = store_their_did(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(identity_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "identity_json"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(_retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_key_for_did(
    pool_handle: i32,
    wallet_handle: i32,
    did: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_key_for_did");

    uniffi::call_with_result(call_status, || {
        let _retval = key_for_did(
            match <i32 as uniffi::FfiConverter>::try_lift(pool_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "pool_handle"))
                }
            },
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "did"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_key_for_local_did(
    wallet_handle: i32,
    did: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_key_for_local_did");

    uniffi::call_with_result(call_status, || {
        let _retval = key_for_local_did(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "did"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_set_endpoint_for_did(
    wallet_handle: i32,
    did: uniffi::RustBuffer,
    address: uniffi::RustBuffer,
    transport_key: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_set_endpoint_for_did");

    uniffi::call_with_result(call_status, || {
        let _retval = set_endpoint_for_did(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(address) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "address"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(transport_key) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "transport_key"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(_retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_get_endpoint_for_did(
    wallet_handle: i32,
    pool_handle: i32,
    did: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_get_endpoint_for_did");

    uniffi::call_with_result(call_status, || {
        let _retval = get_endpoint_for_did(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <i32 as uniffi::FfiConverter>::try_lift(pool_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "pool_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "did"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<FfiConverterTypeStringOptString as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_set_did_metadata(
    wallet_handle: i32,
    tgt_did: uniffi::RustBuffer,
    metadata: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_set_did_metadata");

    uniffi::call_with_result(call_status, || {
        let _retval = set_did_metadata(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(tgt_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "tgt_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(metadata) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "metadata"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(_retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_get_did_metadata(
    wallet_handle: i32,
    tgt_did: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_get_did_metadata");

    uniffi::call_with_result(call_status, || {
        let _retval = get_did_metadata(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(tgt_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "tgt_did"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_get_my_did_with_metadata(
    wallet_handle: i32,
    my_did: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_get_my_did_with_metadata");

    uniffi::call_with_result(call_status, || {
        let _retval = get_my_did_with_metadata(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(my_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "my_did"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_list_my_dids_with_metadata(
    wallet_handle: i32,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_list_my_dids_with_metadata");

    uniffi::call_with_result(call_status, || {
        let _retval = list_my_dids_with_metadata(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_abbreviate_verkey(
    tgt_did: uniffi::RustBuffer,
    verkey: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_abbreviate_verkey");

    uniffi::call_with_result(call_status, || {
        let _retval = abbreviate_verkey(
            match <String as uniffi::FfiConverter>::try_lift(tgt_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "tgt_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(verkey) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "verkey"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_qualify_did(
    wallet_handle: i32,
    did: uniffi::RustBuffer,
    method: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_qualify_did");

    uniffi::call_with_result(call_status, || {
        let _retval = qualify_did(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(method) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "method"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_get_schema(
    pool_handle: i32,
    wallet_handle: i32,
    submitter_did: uniffi::RustBuffer,
    id: uniffi::RustBuffer,
    options_json: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_get_schema");

    uniffi::call_with_result(call_status, || {
        let _retval = get_schema(
            match <i32 as uniffi::FfiConverter>::try_lift(pool_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "pool_handle"))
                }
            },
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(submitter_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "submitter_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(id) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "id"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(options_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "options_json"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_get_cred_def(
    pool_handle: i32,
    wallet_handle: i32,
    submitter_did: uniffi::RustBuffer,
    id: uniffi::RustBuffer,
    options_json: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_get_cred_def");

    uniffi::call_with_result(call_status, || {
        let _retval = get_cred_def(
            match <i32 as uniffi::FfiConverter>::try_lift(pool_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "pool_handle"))
                }
            },
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(submitter_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "submitter_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(id) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "id"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(options_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "options_json"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_purge_schema_cache(
    wallet_handle: i32,
    options_json: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_purge_schema_cache");

    uniffi::call_with_result(call_status, || {
        let _retval = purge_schema_cache(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(options_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "options_json"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(_retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_purge_cred_def_cache(
    wallet_handle: i32,
    options_json: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_purge_cred_def_cache");

    uniffi::call_with_result(call_status, || {
        let _retval = purge_cred_def_cache(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(options_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "options_json"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(_retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_create_key(
    wallet_handle: i32,
    my_key_json: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_create_key");

    uniffi::call_with_result(call_status, || {
        let _retval = create_key(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(my_key_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "my_key_json"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_set_key_metadata(
    wallet_handle: i32,
    verkey: uniffi::RustBuffer,
    metadata: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_set_key_metadata");

    uniffi::call_with_result(call_status, || {
        let _retval = set_key_metadata(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(verkey) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "verkey"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(metadata) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "metadata"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(_retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_get_key_metadata(
    wallet_handle: i32,
    verkey: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_get_key_metadata");

    uniffi::call_with_result(call_status, || {
        let _retval = get_key_metadata(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(verkey) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "verkey"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_sign(
    wallet_handle: i32,
    signer_vk: uniffi::RustBuffer,
    message: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_sign");

    uniffi::call_with_result(call_status, || {
        let _retval = sign(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(signer_vk) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "signer_vk"))
                }
            },
            match <std::vec::Vec<u8> as uniffi::FfiConverter>::try_lift(message) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "message"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<std::vec::Vec<u8> as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_verify(
    signer_vk: uniffi::RustBuffer,
    message: uniffi::RustBuffer,
    signature: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> i8 {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_verify");

    uniffi::call_with_result(call_status, || {
        let _retval = verify(
            match <String as uniffi::FfiConverter>::try_lift(signer_vk) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "signer_vk"))
                }
            },
            match <std::vec::Vec<u8> as uniffi::FfiConverter>::try_lift(message) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "message"))
                }
            },
            match <std::vec::Vec<u8> as uniffi::FfiConverter>::try_lift(signature) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "signature"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<bool as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_auth_crypt(
    wallet_handle: i32,
    sender_vk: uniffi::RustBuffer,
    recipient_vk: uniffi::RustBuffer,
    message: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_auth_crypt");

    uniffi::call_with_result(call_status, || {
        let _retval = auth_crypt(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(sender_vk) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "sender_vk"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(recipient_vk) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "recipient_vk"))
                }
            },
            match <std::vec::Vec<u8> as uniffi::FfiConverter>::try_lift(message) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "message"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<std::vec::Vec<u8> as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_auth_decrypt(
    wallet_handle: i32,
    recipient_vk: uniffi::RustBuffer,
    encrypted_message: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_auth_decrypt");

    uniffi::call_with_result(call_status, || {
        let _retval = auth_decrypt(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(recipient_vk) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "recipient_vk"))
                }
            },
            match <std::vec::Vec<u8> as uniffi::FfiConverter>::try_lift(encrypted_message) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "encrypted_message"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<FfiConverterTypeStringVecU8 as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_anon_crypt(
    recipient_vk: uniffi::RustBuffer,
    message: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_anon_crypt");

    uniffi::call_with_result(call_status, || {
        let _retval = anon_crypt(
            match <String as uniffi::FfiConverter>::try_lift(recipient_vk) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "recipient_vk"))
                }
            },
            match <std::vec::Vec<u8> as uniffi::FfiConverter>::try_lift(message) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "message"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<std::vec::Vec<u8> as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_anon_decrypt(
    wallet_handle: i32,
    recipient_vk: uniffi::RustBuffer,
    encrypted_message: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_anon_decrypt");

    uniffi::call_with_result(call_status, || {
        let _retval = anon_decrypt(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(recipient_vk) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "recipient_vk"))
                }
            },
            match <std::vec::Vec<u8> as uniffi::FfiConverter>::try_lift(encrypted_message) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "encrypted_message"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<std::vec::Vec<u8> as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_pack_message(
    wallet_handle: i32,
    message: uniffi::RustBuffer,
    receiver_keys: uniffi::RustBuffer,
    sender: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_pack_message");

    uniffi::call_with_result(call_status, || {
        let _retval = pack_message(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <std::vec::Vec<u8> as uniffi::FfiConverter>::try_lift(message) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "message"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(receiver_keys) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "receiver_keys"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(sender) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "sender"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<std::vec::Vec<u8> as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_unpack_message(
    wallet_handle: i32,
    jwe: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_unpack_message");

    uniffi::call_with_result(call_status, || {
        let _retval = unpack_message(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <std::vec::Vec<u8> as uniffi::FfiConverter>::try_lift(jwe) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "jwe"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<std::vec::Vec<u8> as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_collect_metrics(
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_collect_metrics");

    uniffi::call_with_result(call_status, || {
        let _retval = collect_metrics()
            .map_err(Into::into)
            .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_is_pairwise_exists(
    wallet_handle: i32,
    their_did: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> i8 {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_is_pairwise_exists");

    uniffi::call_with_result(call_status, || {
        let _retval = is_pairwise_exists(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(their_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "their_did"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<bool as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_create_pairwise(
    wallet_handle: i32,
    their_did: uniffi::RustBuffer,
    my_did: uniffi::RustBuffer,
    metadata: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_create_pairwise");

    uniffi::call_with_result(call_status, || {
        let _retval = create_pairwise(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(their_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "their_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(my_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "my_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(metadata) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "metadata"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(_retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_list_pairwise(
    wallet_handle: i32,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_list_pairwise");

    uniffi::call_with_result(call_status, || {
        let _retval = list_pairwise(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_get_pairwise(
    wallet_handle: i32,
    their_did: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_get_pairwise");

    uniffi::call_with_result(call_status, || {
        let _retval = get_pairwise(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(their_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "their_did"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_set_pairwise_metadata(
    wallet_handle: i32,
    their_did: uniffi::RustBuffer,
    metadata: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_set_pairwise_metadata");

    uniffi::call_with_result(call_status, || {
        let _retval = set_pairwise_metadata(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(their_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "their_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(metadata) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "metadata"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(_retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_sign_and_submit_request(
    pool_handle: i32,
    wallet_handle: i32,
    submitter_did: uniffi::RustBuffer,
    request_json: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_sign_and_submit_request");

    uniffi::call_with_result(call_status, || {
        let _retval = sign_and_submit_request(
            match <i32 as uniffi::FfiConverter>::try_lift(pool_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "pool_handle"))
                }
            },
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(submitter_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "submitter_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(request_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "request_json"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_submit_request(
    pool_handle: i32,
    request_json: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_submit_request");

    uniffi::call_with_result(call_status, || {
        let _retval = submit_request(
            match <i32 as uniffi::FfiConverter>::try_lift(pool_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "pool_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(request_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "request_json"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_submit_action(
    pool_handle: i32,
    request_json: uniffi::RustBuffer,
    nodes: uniffi::RustBuffer,
    wait_timeout: i32,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_submit_action");

    uniffi::call_with_result(call_status, || {
        let _retval = submit_action(
            match <i32 as uniffi::FfiConverter>::try_lift(pool_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "pool_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(request_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "request_json"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(nodes) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "nodes"))
                }
            },
            match <i32 as uniffi::FfiConverter>::try_lift(wait_timeout) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wait_timeout"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_sign_request(
    wallet_handle: i32,
    submitter_did: uniffi::RustBuffer,
    request_json: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_sign_request");

    uniffi::call_with_result(call_status, || {
        let _retval = sign_request(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(submitter_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "submitter_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(request_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "request_json"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_multi_sign_request(
    wallet_handle: i32,
    submitter_did: uniffi::RustBuffer,
    request_json: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_multi_sign_request");

    uniffi::call_with_result(call_status, || {
        let _retval = multi_sign_request(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(submitter_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "submitter_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(request_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "request_json"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_build_get_ddo_request(
    submitter_did: uniffi::RustBuffer,
    target_did: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_build_get_ddo_request");

    uniffi::call_with_result(call_status, || {
        let _retval = build_get_ddo_request(
            match <String as uniffi::FfiConverter>::try_lift(submitter_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "submitter_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(target_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "target_did"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_build_nym_request(
    submitter_did: uniffi::RustBuffer,
    target_did: uniffi::RustBuffer,
    verkey: uniffi::RustBuffer,
    data: uniffi::RustBuffer,
    role: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_build_nym_request");

    uniffi::call_with_result(call_status, || {
        let _retval = build_nym_request(
            match <String as uniffi::FfiConverter>::try_lift(submitter_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "submitter_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(target_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "target_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(verkey) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "verkey"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(data) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "data"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(role) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "role"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_build_get_nym_request(
    submitter_did: uniffi::RustBuffer,
    target_did: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_build_get_nym_request");

    uniffi::call_with_result(call_status, || {
        let _retval = build_get_nym_request(
            match <String as uniffi::FfiConverter>::try_lift(submitter_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "submitter_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(target_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "target_did"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_parse_get_nym_response(
    get_nym_response: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_parse_get_nym_response");

    uniffi::call_with_result(call_status, || {
        let _retval = parse_get_nym_response(
            match <String as uniffi::FfiConverter>::try_lift(get_nym_response) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "get_nym_response"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_build_get_txn_request(
    submitter_did: uniffi::RustBuffer,
    ledger_type: uniffi::RustBuffer,
    seq_no: i32,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_build_get_txn_request");

    uniffi::call_with_result(call_status, || {
        let _retval = build_get_txn_request(
            match <String as uniffi::FfiConverter>::try_lift(submitter_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "submitter_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(ledger_type) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "ledger_type"))
                }
            },
            match <i32 as uniffi::FfiConverter>::try_lift(seq_no) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "seq_no"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_build_attrib_request(
    submitter_did: uniffi::RustBuffer,
    target_did: uniffi::RustBuffer,
    hash: uniffi::RustBuffer,
    raw: uniffi::RustBuffer,
    enc: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_build_attrib_request");

    uniffi::call_with_result(call_status, || {
        let _retval = build_attrib_request(
            match <String as uniffi::FfiConverter>::try_lift(submitter_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "submitter_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(target_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "target_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(hash) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "hash"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(raw) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "raw"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(enc) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "enc"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_build_get_attrib_request(
    submitter_did: uniffi::RustBuffer,
    target_did: uniffi::RustBuffer,
    raw: uniffi::RustBuffer,
    hash: uniffi::RustBuffer,
    enc: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_build_get_attrib_request");

    uniffi::call_with_result(call_status, || {
        let _retval = build_get_attrib_request(
            match <String as uniffi::FfiConverter>::try_lift(submitter_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "submitter_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(target_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "target_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(raw) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "raw"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(hash) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "hash"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(enc) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "enc"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_build_schema_request(
    ubmitter_did: uniffi::RustBuffer,
    data: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_build_schema_request");

    uniffi::call_with_result(call_status, || {
        let _retval = build_schema_request(
            match <String as uniffi::FfiConverter>::try_lift(ubmitter_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "ubmitter_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(data) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "data"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_build_get_schema_request(
    submitter_did: uniffi::RustBuffer,
    id: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_build_get_schema_request");

    uniffi::call_with_result(call_status, || {
        let _retval = build_get_schema_request(
            match <String as uniffi::FfiConverter>::try_lift(submitter_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "submitter_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(id) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "id"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_parse_get_schema_response(
    get_schema_response: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_parse_get_schema_response");

    uniffi::call_with_result(call_status, || {
        let _retval = parse_get_schema_response(
            match <String as uniffi::FfiConverter>::try_lift(get_schema_response) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "get_schema_response"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<FfiConverterTypeStringString as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_build_cred_def_request(
    submitter_did: uniffi::RustBuffer,
    data: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_build_cred_def_request");

    uniffi::call_with_result(call_status, || {
        let _retval = build_cred_def_request(
            match <String as uniffi::FfiConverter>::try_lift(submitter_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "submitter_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(data) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "data"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_build_get_cred_def_request(
    submitter_did: uniffi::RustBuffer,
    id: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_build_get_cred_def_request");

    uniffi::call_with_result(call_status, || {
        let _retval = build_get_cred_def_request(
            match <String as uniffi::FfiConverter>::try_lift(submitter_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "submitter_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(id) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "id"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_parse_get_cred_def_response(
    get_cred_def_response: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_parse_get_cred_def_response");

    uniffi::call_with_result(call_status, || {
        let _retval = parse_get_cred_def_response(
            match <String as uniffi::FfiConverter>::try_lift(get_cred_def_response) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "get_cred_def_response"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<FfiConverterTypeStringString as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_build_node_request(
    submitter_did: uniffi::RustBuffer,
    target_did: uniffi::RustBuffer,
    data: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_build_node_request");

    uniffi::call_with_result(call_status, || {
        let _retval = build_node_request(
            match <String as uniffi::FfiConverter>::try_lift(submitter_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "submitter_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(target_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "target_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(data) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "data"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_build_get_validator_info_request(
    submitter_did: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_build_get_validator_info_request");

    uniffi::call_with_result(call_status, || {
        let _retval = build_get_validator_info_request(
            match <String as uniffi::FfiConverter>::try_lift(submitter_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "submitter_did"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_build_pool_config_request(
    submitter_did: uniffi::RustBuffer,
    writes: i8,
    force: i8,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_build_pool_config_request");

    uniffi::call_with_result(call_status, || {
        let _retval = build_pool_config_request(
            match <String as uniffi::FfiConverter>::try_lift(submitter_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "submitter_did"))
                }
            },
            match <bool as uniffi::FfiConverter>::try_lift(writes) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "writes"))
                }
            },
            match <bool as uniffi::FfiConverter>::try_lift(force) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "force"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_build_pool_restart_request(
    submitter_did: uniffi::RustBuffer,
    action: uniffi::RustBuffer,
    datetime: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_build_pool_restart_request");

    uniffi::call_with_result(call_status, || {
        let _retval = build_pool_restart_request(
            match <String as uniffi::FfiConverter>::try_lift(submitter_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "submitter_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(action) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "action"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(datetime) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "datetime"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_build_pool_upgrade_request(
    submitter_did: uniffi::RustBuffer,
    name: uniffi::RustBuffer,
    version: uniffi::RustBuffer,
    action: uniffi::RustBuffer,
    sha256: uniffi::RustBuffer,
    upgrade_timeout: u32,
    schedule: uniffi::RustBuffer,
    justification: uniffi::RustBuffer,
    reinstall: i8,
    force: i8,
    package: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_build_pool_upgrade_request");

    uniffi::call_with_result(call_status, || {
        let _retval = build_pool_upgrade_request(
            match <String as uniffi::FfiConverter>::try_lift(submitter_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "submitter_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(name) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "name"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(version) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "version"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(action) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "action"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(sha256) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "sha256"))
                }
            },
            match <u32 as uniffi::FfiConverter>::try_lift(upgrade_timeout) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "upgrade_timeout"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(schedule) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "schedule"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(justification) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "justification"))
                }
            },
            match <bool as uniffi::FfiConverter>::try_lift(reinstall) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "reinstall"))
                }
            },
            match <bool as uniffi::FfiConverter>::try_lift(force) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "force"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(package) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "package"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_build_revoc_reg_def_request(
    submitter_did: uniffi::RustBuffer,
    data: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_build_revoc_reg_def_request");

    uniffi::call_with_result(call_status, || {
        let _retval = build_revoc_reg_def_request(
            match <String as uniffi::FfiConverter>::try_lift(submitter_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "submitter_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(data) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "data"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_build_get_revoc_reg_def_request(
    submitter_did: uniffi::RustBuffer,
    id: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_build_get_revoc_reg_def_request");

    uniffi::call_with_result(call_status, || {
        let _retval = build_get_revoc_reg_def_request(
            match <String as uniffi::FfiConverter>::try_lift(submitter_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "submitter_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(id) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "id"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_parse_get_revoc_reg_def_response(
    get_revoc_reg_def_response: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_parse_get_revoc_reg_def_response");

    uniffi::call_with_result(call_status, || {
        let _retval = parse_get_revoc_reg_def_response(
            match <String as uniffi::FfiConverter>::try_lift(get_revoc_reg_def_response) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "get_revoc_reg_def_response"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<FfiConverterTypeStringString as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_build_revoc_reg_entry_request(
    submitter_did: uniffi::RustBuffer,
    revoc_reg_def_id: uniffi::RustBuffer,
    rev_def_type: uniffi::RustBuffer,
    value: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_build_revoc_reg_entry_request");

    uniffi::call_with_result(call_status, || {
        let _retval = build_revoc_reg_entry_request(
            match <String as uniffi::FfiConverter>::try_lift(submitter_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "submitter_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(revoc_reg_def_id) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "revoc_reg_def_id"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(rev_def_type) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "rev_def_type"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(value) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "value"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_build_get_revoc_reg_request(
    submitter_did: uniffi::RustBuffer,
    revoc_reg_def_id: uniffi::RustBuffer,
    timestamp: i64,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_build_get_revoc_reg_request");

    uniffi::call_with_result(call_status, || {
        let _retval = build_get_revoc_reg_request(
            match <String as uniffi::FfiConverter>::try_lift(submitter_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "submitter_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(revoc_reg_def_id) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "revoc_reg_def_id"))
                }
            },
            match <i64 as uniffi::FfiConverter>::try_lift(timestamp) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "timestamp"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_parse_get_revoc_reg_response(
    get_revoc_reg_response: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_parse_get_revoc_reg_response");

    uniffi::call_with_result(call_status, || {
        let _retval = parse_get_revoc_reg_response(
            match <String as uniffi::FfiConverter>::try_lift(get_revoc_reg_response) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "get_revoc_reg_response"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<FfiConverterTypeStringStringU64 as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_build_get_revoc_reg_delta_request(
    submitter_did: uniffi::RustBuffer,
    revoc_reg_def_id: uniffi::RustBuffer,
    from: i64,
    to: i64,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_build_get_revoc_reg_delta_request");

    uniffi::call_with_result(call_status, || {
        let _retval = build_get_revoc_reg_delta_request(
            match <String as uniffi::FfiConverter>::try_lift(submitter_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "submitter_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(revoc_reg_def_id) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "revoc_reg_def_id"))
                }
            },
            match <i64 as uniffi::FfiConverter>::try_lift(from) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "from"))
                }
            },
            match <i64 as uniffi::FfiConverter>::try_lift(to) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "to"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_parse_get_revoc_reg_delta_response(
    get_revoc_reg_delta_response: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_parse_get_revoc_reg_delta_response");

    uniffi::call_with_result(call_status, || {
        let _retval = parse_get_revoc_reg_delta_response(
            match <String as uniffi::FfiConverter>::try_lift(get_revoc_reg_delta_response) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "get_revoc_reg_delta_response"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<FfiConverterTypeStringStringU64 as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_get_response_metadata(
    response: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_get_response_metadata");

    uniffi::call_with_result(call_status, || {
        let _retval =
            get_response_metadata(match <String as uniffi::FfiConverter>::try_lift(response) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "response"))
                }
            })
            .map_err(Into::into)
            .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_build_auth_rule_request(
    submitter_did: uniffi::RustBuffer,
    txn_type: uniffi::RustBuffer,
    action: uniffi::RustBuffer,
    field: uniffi::RustBuffer,
    old_value: uniffi::RustBuffer,
    new_value: uniffi::RustBuffer,
    constraint: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_build_auth_rule_request");

    uniffi::call_with_result(call_status, || {
        let _retval = build_auth_rule_request(
            match <String as uniffi::FfiConverter>::try_lift(submitter_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "submitter_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(txn_type) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "txn_type"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(action) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "action"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(field) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "field"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(old_value) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "old_value"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(new_value) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "new_value"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(constraint) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "constraint"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_build_auth_rules_request(
    submitter_did: uniffi::RustBuffer,
    data: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_build_auth_rules_request");

    uniffi::call_with_result(call_status, || {
        let _retval = build_auth_rules_request(
            match <String as uniffi::FfiConverter>::try_lift(submitter_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "submitter_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(data) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "data"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_build_get_auth_rule_request(
    submitter_did: uniffi::RustBuffer,
    txn_type: uniffi::RustBuffer,
    action: uniffi::RustBuffer,
    field: uniffi::RustBuffer,
    old_value: uniffi::RustBuffer,
    new_value: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_build_get_auth_rule_request");

    uniffi::call_with_result(call_status, || {
        let _retval = build_get_auth_rule_request(
            match <String as uniffi::FfiConverter>::try_lift(submitter_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "submitter_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(txn_type) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "txn_type"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(action) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "action"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(field) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "field"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(old_value) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "old_value"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(new_value) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "new_value"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_build_txn_author_agreement_request(
    submitter_did: uniffi::RustBuffer,
    text: uniffi::RustBuffer,
    version: uniffi::RustBuffer,
    ratification_ts: uniffi::RustBuffer,
    retirement_ts: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_build_txn_author_agreement_request");

    uniffi::call_with_result(call_status, || {
        let _retval = build_txn_author_agreement_request(
            match <String as uniffi::FfiConverter>::try_lift(submitter_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "submitter_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(text) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "text"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(version) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "version"))
                }
            },
            match <std::option::Option<u64> as uniffi::FfiConverter>::try_lift(ratification_ts) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "ratification_ts"))
                }
            },
            match <std::option::Option<u64> as uniffi::FfiConverter>::try_lift(retirement_ts) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "retirement_ts"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_build_disable_all_txn_author_agreements_request(
    submitter_did: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_build_disable_all_txn_author_agreements_request");

    uniffi::call_with_result(call_status, || {
        let _retval = build_disable_all_txn_author_agreements_request(
            match <String as uniffi::FfiConverter>::try_lift(submitter_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "submitter_did"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_build_get_txn_author_agreement_request(
    submitter_did: uniffi::RustBuffer,
    data: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_build_get_txn_author_agreement_request");

    uniffi::call_with_result(call_status, || {
        let _retval = build_get_txn_author_agreement_request(
            match <String as uniffi::FfiConverter>::try_lift(submitter_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "submitter_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(data) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "data"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_build_acceptance_mechanisms_request(
    submitter_did: uniffi::RustBuffer,
    aml: uniffi::RustBuffer,
    version: uniffi::RustBuffer,
    aml_context: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_build_acceptance_mechanisms_request");

    uniffi::call_with_result(call_status, || {
        let _retval = build_acceptance_mechanisms_request(
            match <String as uniffi::FfiConverter>::try_lift(submitter_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "submitter_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(aml) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "aml"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(version) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "version"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(aml_context) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "aml_context"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_build_get_acceptance_mechanisms_request(
    submitter_did: uniffi::RustBuffer,
    timestamp: i64,
    version: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_build_get_acceptance_mechanisms_request");

    uniffi::call_with_result(call_status, || {
        let _retval = build_get_acceptance_mechanisms_request(
            match <String as uniffi::FfiConverter>::try_lift(submitter_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "submitter_did"))
                }
            },
            match <i64 as uniffi::FfiConverter>::try_lift(timestamp) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "timestamp"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(version) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "version"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_append_txn_author_agreement_acceptance_to_request(
    request_json: uniffi::RustBuffer,
    text: uniffi::RustBuffer,
    version: uniffi::RustBuffer,
    taa_digest: uniffi::RustBuffer,
    mechanism: uniffi::RustBuffer,
    time: u64,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_append_txn_author_agreement_acceptance_to_request");

    uniffi::call_with_result(call_status, || {
        let _retval = append_txn_author_agreement_acceptance_to_request(
            match <String as uniffi::FfiConverter>::try_lift(request_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "request_json"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(text) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "text"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(version) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "version"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(taa_digest) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "taa_digest"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(mechanism) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "mechanism"))
                }
            },
            match <u64 as uniffi::FfiConverter>::try_lift(time) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "time"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_append_request_endorser(
    request_json: uniffi::RustBuffer,
    endorser_did: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_append_request_endorser");

    uniffi::call_with_result(call_status, || {
        let _retval = append_request_endorser(
            match <String as uniffi::FfiConverter>::try_lift(request_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "request_json"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(endorser_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "endorser_did"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_build_ledgers_freeze_request(
    submitter_did: uniffi::RustBuffer,
    ledgers_ids: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_build_ledgers_freeze_request");

    uniffi::call_with_result(call_status, || {
        let _retval = build_ledgers_freeze_request(
            match <String as uniffi::FfiConverter>::try_lift(submitter_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "submitter_did"))
                }
            },
            match <std::vec::Vec<u64> as uniffi::FfiConverter>::try_lift(ledgers_ids) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "ledgers_ids"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_build_get_frozen_ledgers_request(
    submitter_did: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_build_get_frozen_ledgers_request");

    uniffi::call_with_result(call_status, || {
        let _retval = build_get_frozen_ledgers_request(
            match <String as uniffi::FfiConverter>::try_lift(submitter_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "submitter_did"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_issuer_create_schema(
    issuer_did: uniffi::RustBuffer,
    name: uniffi::RustBuffer,
    version: uniffi::RustBuffer,
    attrs: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_issuer_create_schema");

    uniffi::call_with_result(call_status, || {
        let _retval = issuer_create_schema(
            match <String as uniffi::FfiConverter>::try_lift(issuer_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "issuer_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(name) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "name"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(version) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "version"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(attrs) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "attrs"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<FfiConverterTypeStringString as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_issuer_create_and_store_credential_def(
    wallet_handle: i32,
    issuer_did: uniffi::RustBuffer,
    schema_json: uniffi::RustBuffer,
    tag: uniffi::RustBuffer,
    signature_type: uniffi::RustBuffer,
    config_json: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_issuer_create_and_store_credential_def");

    uniffi::call_with_result(call_status, || {
        let _retval = issuer_create_and_store_credential_def(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(issuer_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "issuer_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(schema_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "schema_json"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(tag) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "tag"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(signature_type) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "signature_type"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(config_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "config_json"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<FfiConverterTypeStringString as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_issuer_rotate_credential_def_start(
    wallet_handle: i32,
    cred_def_id: uniffi::RustBuffer,
    config_json: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_issuer_rotate_credential_def_start");

    uniffi::call_with_result(call_status, || {
        let _retval = issuer_rotate_credential_def_start(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(cred_def_id) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "cred_def_id"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(config_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "config_json"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_issuer_rotate_credential_def_apply(
    wallet_handle: i32,
    cred_def_id: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_issuer_rotate_credential_def_apply");

    uniffi::call_with_result(call_status, || {
        let _retval = issuer_rotate_credential_def_apply(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(cred_def_id) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "cred_def_id"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(_retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_issuer_create_and_store_revoc_reg(
    wallet_handle: i32,
    issuer_did: uniffi::RustBuffer,
    revoc_def_type: uniffi::RustBuffer,
    tag: uniffi::RustBuffer,
    cred_def_id: uniffi::RustBuffer,
    config_json: uniffi::RustBuffer,
    tails_writer_handle: i32,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_issuer_create_and_store_revoc_reg");

    uniffi::call_with_result(call_status, || {
        let _retval = issuer_create_and_store_revoc_reg(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(issuer_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "issuer_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(revoc_def_type) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "revoc_def_type"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(tag) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "tag"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(cred_def_id) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "cred_def_id"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(config_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "config_json"))
                }
            },
            match <i32 as uniffi::FfiConverter>::try_lift(tails_writer_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "tails_writer_handle"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<FfiConverterTypeStringStringString as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_issuer_create_credential_offer(
    wallet_handle: i32,
    cred_def_id: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_issuer_create_credential_offer");

    uniffi::call_with_result(call_status, || {
        let _retval = issuer_create_credential_offer(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(cred_def_id) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "cred_def_id"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_issuer_create_credential(
    wallet_handle: i32,
    cred_offer_json: uniffi::RustBuffer,
    cred_req_json: uniffi::RustBuffer,
    cred_values_json: uniffi::RustBuffer,
    rev_reg_id: uniffi::RustBuffer,
    blob_storage_reader_handle: i32,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_issuer_create_credential");

    uniffi::call_with_result(call_status, || {
        let _retval = issuer_create_credential(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(cred_offer_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "cred_offer_json"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(cred_req_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "cred_req_json"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(cred_values_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "cred_values_json"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(rev_reg_id) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "rev_reg_id"))
                }
            },
            match <i32 as uniffi::FfiConverter>::try_lift(blob_storage_reader_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "blob_storage_reader_handle"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<FfiConverterTypeStringStringString122 as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_issuer_revoke_credential(
    wallet_handle: i32,
    blob_storage_reader_cfg_handle: i32,
    rev_reg_id: uniffi::RustBuffer,
    cred_revoc_id: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_issuer_revoke_credential");

    uniffi::call_with_result(call_status, || {
        let _retval = issuer_revoke_credential(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <i32 as uniffi::FfiConverter>::try_lift(blob_storage_reader_cfg_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "blob_storage_reader_cfg_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(rev_reg_id) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "rev_reg_id"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(cred_revoc_id) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "cred_revoc_id"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_issuer_merge_revocation_registry_deltas(
    rev_reg_delta_json: uniffi::RustBuffer,
    other_rev_reg_delta_json: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_issuer_merge_revocation_registry_deltas");

    uniffi::call_with_result(call_status, || {
        let _retval = issuer_merge_revocation_registry_deltas(
            match <String as uniffi::FfiConverter>::try_lift(rev_reg_delta_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "rev_reg_delta_json"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(other_rev_reg_delta_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "other_rev_reg_delta_json"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_prover_create_master_secret(
    wallet_handle: i32,
    master_secret_id: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_prover_create_master_secret");

    uniffi::call_with_result(call_status, || {
        let _retval = prover_create_master_secret(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(master_secret_id) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "master_secret_id"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_prover_get_credential(
    wallet_handle: i32,
    cred_id: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_prover_get_credential");

    uniffi::call_with_result(call_status, || {
        let _retval = prover_get_credential(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(cred_id) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "cred_id"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_prover_delete_credential(
    wallet_handle: i32,
    cred_id: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_prover_delete_credential");

    uniffi::call_with_result(call_status, || {
        let _retval = prover_delete_credential(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(cred_id) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "cred_id"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(_retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_prover_create_credential_req(
    wallet_handle: i32,
    prover_did: uniffi::RustBuffer,
    cred_offer_json: uniffi::RustBuffer,
    cred_def_json: uniffi::RustBuffer,
    master_secret_id: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_prover_create_credential_req");

    uniffi::call_with_result(call_status, || {
        let _retval = prover_create_credential_req(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(prover_did) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "prover_did"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(cred_offer_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "cred_offer_json"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(cred_def_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "cred_def_json"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(master_secret_id) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "master_secret_id"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<FfiConverterTypeStringString as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_prover_set_credential_attr_tag_policy(
    wallet_handle: i32,
    cred_def_id: uniffi::RustBuffer,
    tag_attrs_json: uniffi::RustBuffer,
    retroactive: i8,
    call_status: &mut uniffi::RustCallStatus,
) {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_prover_set_credential_attr_tag_policy");

    uniffi::call_with_result(call_status, || {
        let _retval = prover_set_credential_attr_tag_policy(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(cred_def_id) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "cred_def_id"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(tag_attrs_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "tag_attrs_json"))
                }
            },
            match <bool as uniffi::FfiConverter>::try_lift(retroactive) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "retroactive"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(_retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_prover_get_credential_attr_tag_policy(
    wallet_handle: i32,
    cred_id: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_prover_get_credential_attr_tag_policy");

    uniffi::call_with_result(call_status, || {
        let _retval = prover_get_credential_attr_tag_policy(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(cred_id) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "cred_id"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_prover_store_credential(
    wallet_handle: i32,
    cred_id: uniffi::RustBuffer,
    cred_req_metadata_json: uniffi::RustBuffer,
    cred_json: uniffi::RustBuffer,
    cred_def_json: uniffi::RustBuffer,
    rev_reg_def_json: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_prover_store_credential");

    uniffi::call_with_result(call_status, || {
        let _retval = prover_store_credential(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(cred_id) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "cred_id"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(cred_req_metadata_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "cred_req_metadata_json"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(cred_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "cred_json"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(cred_def_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "cred_def_json"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(rev_reg_def_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "rev_reg_def_json"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_prover_get_credentials(
    wallet_handle: i32,
    filter_json: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_prover_get_credentials");

    uniffi::call_with_result(call_status, || {
        let _retval = prover_get_credentials(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(filter_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "filter_json"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_prover_search_credentials(
    wallet_handle: i32,
    query_json: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_prover_search_credentials");

    uniffi::call_with_result(call_status, || {
        let _retval = prover_search_credentials(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(query_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "query_json"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<FfiConverterTypeSearchHandleAndLength as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_prover_fetch_credentials(
    search_handle: i32,
    count: u64,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_prover_fetch_credentials");

    uniffi::call_with_result(call_status, || {
        let _retval = prover_fetch_credentials(
            match <i32 as uniffi::FfiConverter>::try_lift(search_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "search_handle"))
                }
            },
            match <u64 as uniffi::FfiConverter>::try_lift(count) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "count"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_prover_close_credentials_search(
    search_handle: i32,
    call_status: &mut uniffi::RustCallStatus,
) {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_prover_close_credentials_search");

    uniffi::call_with_result(call_status, || {
        let _retval = prover_close_credentials_search(
            match <i32 as uniffi::FfiConverter>::try_lift(search_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "search_handle"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(_retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_prover_get_credentials_for_proof_req(
    wallet_handle: i32,
    proof_request_json: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_prover_get_credentials_for_proof_req");

    uniffi::call_with_result(call_status, || {
        let _retval = prover_get_credentials_for_proof_req(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(proof_request_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "proof_request_json"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_prover_search_credentials_for_proof_req(
    wallet_handle: i32,
    proof_request_json: uniffi::RustBuffer,
    extra_query_json: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> i32 {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_prover_search_credentials_for_proof_req");

    uniffi::call_with_result(call_status, || {
        let _retval = prover_search_credentials_for_proof_req(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(proof_request_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "proof_request_json"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(extra_query_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "extra_query_json"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<i32 as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_prover_fetch_credentials_for_proof_req(
    search_handle: i32,
    item_referent: uniffi::RustBuffer,
    count: u64,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_prover_fetch_credentials_for_proof_req");

    uniffi::call_with_result(call_status, || {
        let _retval = prover_fetch_credentials_for_proof_req(
            match <i32 as uniffi::FfiConverter>::try_lift(search_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "search_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(item_referent) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "item_referent"))
                }
            },
            match <u64 as uniffi::FfiConverter>::try_lift(count) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "count"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_prover_close_credentials_search_for_proof_req(
    search_handle: i32,
    call_status: &mut uniffi::RustCallStatus,
) {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_prover_close_credentials_search_for_proof_req");

    uniffi::call_with_result(call_status, || {
        let _retval = prover_close_credentials_search_for_proof_req(
            match <i32 as uniffi::FfiConverter>::try_lift(search_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "search_handle"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(_retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_prover_create_proof(
    wallet_handle: i32,
    proof_req_json: uniffi::RustBuffer,
    requested_credentials_json: uniffi::RustBuffer,
    master_secret_id: uniffi::RustBuffer,
    schemas_json: uniffi::RustBuffer,
    credential_defs_json: uniffi::RustBuffer,
    rev_states_json: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_prover_create_proof");

    uniffi::call_with_result(call_status, || {
        let _retval = prover_create_proof(
            match <i32 as uniffi::FfiConverter>::try_lift(wallet_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "wallet_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(proof_req_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "proof_req_json"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(requested_credentials_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "requested_credentials_json"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(master_secret_id) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "master_secret_id"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(schemas_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "schemas_json"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(credential_defs_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "credential_defs_json"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(rev_states_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "rev_states_json"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_verifier_verify_proof(
    proof_request_json: uniffi::RustBuffer,
    proof_json: uniffi::RustBuffer,
    schemas_json: uniffi::RustBuffer,
    credential_defs_json: uniffi::RustBuffer,
    rev_reg_defs_json: uniffi::RustBuffer,
    rev_regs_json: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> i8 {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_verifier_verify_proof");

    uniffi::call_with_result(call_status, || {
        let _retval = verifier_verify_proof(
            match <String as uniffi::FfiConverter>::try_lift(proof_request_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "proof_request_json"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(proof_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "proof_json"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(schemas_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "schemas_json"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(credential_defs_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "credential_defs_json"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(rev_reg_defs_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "rev_reg_defs_json"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(rev_regs_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "rev_regs_json"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<bool as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_create_revocation_state(
    blob_storage_reader_handle: i32,
    rev_reg_def_json: uniffi::RustBuffer,
    rev_reg_delta_json: uniffi::RustBuffer,
    timestamp: u64,
    cred_rev_id: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_create_revocation_state");

    uniffi::call_with_result(call_status, || {
        let _retval = create_revocation_state(
            match <i32 as uniffi::FfiConverter>::try_lift(blob_storage_reader_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "blob_storage_reader_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(rev_reg_def_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "rev_reg_def_json"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(rev_reg_delta_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "rev_reg_delta_json"))
                }
            },
            match <u64 as uniffi::FfiConverter>::try_lift(timestamp) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "timestamp"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(cred_rev_id) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "cred_rev_id"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_update_revocation_state(
    blob_storage_reader_handle: i32,
    rev_state_json: uniffi::RustBuffer,
    rev_reg_def_json: uniffi::RustBuffer,
    rev_reg_delta_json: uniffi::RustBuffer,
    timestamp: u64,
    cred_rev_id: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_update_revocation_state");

    uniffi::call_with_result(call_status, || {
        let _retval = update_revocation_state(
            match <i32 as uniffi::FfiConverter>::try_lift(blob_storage_reader_handle) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "blob_storage_reader_handle"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(rev_state_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "rev_state_json"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(rev_reg_def_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "rev_reg_def_json"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(rev_reg_delta_json) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "rev_reg_delta_json"))
                }
            },
            match <u64 as uniffi::FfiConverter>::try_lift(timestamp) {
                Ok(val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "timestamp"))
                }
            },
            match <String as uniffi::FfiConverter>::try_lift(cred_rev_id) {
                Ok(ref val) => val,

                Err(err) => {
                    return Err(uniffi::lower_anyhow_error_or_panic::<
                        FfiConverterTypeIndyError2,
                    >(err, "cred_rev_id"))
                }
            },
        )
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_generate_nonce(
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_generate_nonce");

    uniffi::call_with_result(call_status, || {
        let _retval = generate_nonce()
            .map_err(Into::into)
            .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn lib_2f6d_to_unqualified(
    entity: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("lib_2f6d_to_unqualified");

    uniffi::call_with_result(call_status, || {
        let _retval = to_unqualified(match <String as uniffi::FfiConverter>::try_lift(entity) {
            Ok(ref val) => val,

            Err(err) => {
                return Err(uniffi::lower_anyhow_error_or_panic::<
                    FfiConverterTypeIndyError2,
                >(err, "entity"))
            }
        })
        .map_err(Into::into)
        .map_err(<FfiConverterTypeIndyError2 as uniffi::FfiConverter>::lower)?;
        Ok(<String as uniffi::FfiConverter>::lower(_retval))
    })
}
// Object definitions, corresponding to UDL `interface` definitions.

// Callback Interface definitions, corresponding to UDL `callback interface` definitions.

// External and Wrapped types
// Support for external types.

// Types with an external `FfiConverter`...

// More complicated locally `Wrapped` types - we generate FfiConverter.
